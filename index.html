<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>InfiniteCanva - CreateWithoutBoundry</title>
    <!-- FontAwesome CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', 'Helvetica Neue', Helvetica, Arial, sans-serif;
            background: #e5e5e5;
            height: 100vh;
            overflow: hidden;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .container {
            width: 100%;
            height: 100vh;
            position: relative;
        }

        /* Canvas区域 */
        .canvas-container {
            width: 100%;
            height: 100%;
            background: #e5e5e5;
            position: relative;
        }

        /* Excel表格容器 */
        .excel-container {
            position: absolute;
            left: 40px;
            top: 80px;
            width: 32%;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            padding: 20px;
            max-height: 70vh;
            overflow: hidden; /* 容器本身不滚动 */
            cursor: move;
            user-select: none;
            z-index: 10; /* Excel容器层级最低 */
        }

        /* 隐藏Excel容器滚动条 */
        .excel-container::-webkit-scrollbar {
            width: 0px;
            background: transparent;
            display: none; /* Chrome, Safari, Opera */
        }

        .excel-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }

        .excel-table th {
            background: #f8f9fa;
            padding: 10px 12px;
            text-align: left;
            font-weight: 600;
            color: #495057;
            border-bottom: 2px solid #dee2e6;
        }

        .excel-table td {
            padding: 8px 12px;
            border-bottom: 1px solid #e9ecef;
            color: #495057;
        }

        .excel-table tr:hover {
            background: #f8f9fa;
        }

        .search-query {
            font-weight: 500;
        }

        .search-frequency {
            text-align: right;
            font-weight: 600;
            color: #0066cc;
        }

        .excel-container:hover {
            box-shadow: 0 6px 25px rgba(0, 0, 0, 0.15);
        }

        /* Word文档容器 */
        .word-container {
            position: absolute;
            left: 34%;
            top: 80px;
            width: 32%;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            border: none;
            max-height: 70vh;
            overflow: hidden;
            padding: 20px;
            cursor: move;
            user-select: none;
            z-index: 20; /* Word容器层级中等 */
        }

        .word-container:hover {
            box-shadow: 0 6px 25px rgba(0, 0, 0, 0.15);
        }

        /* 拖拽时的样式 */
        .dragging {
            z-index: 1000; /* 拖拽时最高层级 */
            transform: rotate(2deg);
            opacity: 0.9;
        }

        /* 选中状态的样式 */
        .selected {
            border: 3px solid #007bff;
            box-shadow: 0 6px 30px rgba(0, 123, 255, 0.3);
        }

        /* 调整大小功能样式 */
        .resizable {
            resize: both;
            overflow: auto;
            min-width: 200px;
            min-height: 150px;
        }

        /* 调整大小手柄样式 */
        .resize-handle {
            position: absolute;
            background: transparent; /* 完全透明背景 */
            opacity: 0; /* 完全透明 */
            transition: none; /* 移除过渡效果 */
        }

        .resize-handle:hover {
            opacity: 0; /* 悬停时也保持透明 */
            background: transparent; /* 确保背景透明 */
        }

        .selected .resize-handle {
            opacity: 0; /* 选中时也保持透明 */
            background: transparent; /* 确保背景透明 */
        }

        .selected .resize-handle:hover {
            opacity: 0; /* 选中且悬停时也保持透明 */
            background: transparent; /* 确保背景透明 */
        }

        /* 调整大小时隐藏手柄 */
        .resizing .resize-handle {
            opacity: 0 !important;
            background: transparent !important;
        }

        /* 调整大小时隐藏选中边框 */
        .resizing.selected {
            border: none !important;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1) !important;
        }

        /* 右下角调整大小手柄 */
        .resize-handle-se {
            width: 15px;
            height: 15px;
            bottom: 0;
            right: 0;
            cursor: se-resize;
        }

        /* 右边调整大小手柄 */
        .resize-handle-e {
            width: 5px;
            height: 100%;
            top: 0;
            right: 0;
            cursor: e-resize;
        }

        /* 底部调整大小手柄 */
        .resize-handle-s {
            width: 100%;
            height: 5px;
            bottom: 0;
            left: 0;
            cursor: s-resize;
        }

        /* 文档复选框样式 */
        .document-checkbox {
            position: absolute;
            top: 10px;
            right: 10px;
        }

        /* Excel复选框层级 */
        .excel-container .document-checkbox {
            z-index: 15; /* Excel复选框 */
            top: 13px; /* 与工具栏中的Microsoft Excel文字垂直对齐 */
        }

        /* Word复选框层级 */
        .word-container .document-checkbox {
            z-index: 25; /* Word复选框 */
        }

        /* Claude复选框层级 */
        .claude-output-container .document-checkbox {
            z-index: 35; /* Claude复选框，最高层级 */
        }

        .checkbox-input {
            display: none;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            border: 2px solid #ddd;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .checkbox-label:hover {
            border-color: #007bff;
            box-shadow: 0 2px 8px rgba(0, 123, 255, 0.2);
        }

        .checkbox-label i {
            font-size: 12px;
            color: transparent;
            transition: color 0.2s ease;
        }

        .checkbox-input:checked + .checkbox-label {
            background: #007bff;
            border-color: #007bff;
            box-shadow: 0 2px 8px rgba(0, 123, 255, 0.3);
        }

        .checkbox-input:checked + .checkbox-label i {
            color: white;
        }

        /* Excel工具栏样式 */
        .excel-toolbar {
            background: #f8f9fa; /* 与Word相同的灰色背景 */
            border-bottom: 1px solid #e5e7eb; /* 与Word相同的边框色 */
            padding: 8px 50px 8px 15px; /* 为复选框留空间 */
            font-size: 11px;
            color: #6b7280; /* 与Word相同的文字颜色 */
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin: -20px -20px 0 -20px;
        }

        .excel-filename {
            font-weight: 500;
            color: #374151; /* 与Word相同的文件名颜色 */
        }

        .excel-filename i {
            color: #217346; /* Excel绿色图标 */
            margin-right: 6px;
        }

        .excel-title {
            font-size: 16px;
            font-weight: 600;
            color: #333;
            margin-bottom: 15px;
            text-align: center;
        }

        .excel-content {
            padding: 20px;
            height: calc(100% - 70px); /* 动态高度，减去工具栏高度 */
            overflow-y: auto;
            background: white;
            margin: 0;
            box-shadow: none;
            /* 隐藏滚动条但保持滚动功能 */
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE and Edge */
        }

        /* 隐藏Excel内容滚动条但保持滚动功能 */
        .excel-content::-webkit-scrollbar {
            width: 0px;
            background: transparent;
            display: none; /* Chrome, Safari, Opera */
        }

        /* Word工具栏样式 */
        .word-toolbar {
            background: #f8f9fa; /* 与Excel相同的灰色背景 */
            border-bottom: 1px solid #e5e7eb; /* 与Excel相同的边框色 */
            padding: 8px 50px 8px 15px; /* 为复选框留空间 */
            font-size: 11px;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; /* 与Excel相同的系统字体 */
            color: #6b7280; /* 与Excel相同的文字颜色 */
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin: -20px -20px 0 -20px;
        }

        .word-filename {
            font-weight: 500;
            color: #374151; /* 与Excel相同的文件名颜色 */
        }

        .word-filename i {
            color: #2b579a; /* Word蓝色图标 */
            margin-right: 6px;
        }

        .word-toolbar-right {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .word-document {
            padding: 20px;
            height: calc(100% - 70px); /* 动态高度，与Excel相同，减去工具栏高度 */
            overflow-y: auto;
            background: white;
            margin: 0;
            box-shadow: none;
            font-family: 'Calibri', 'Times New Roman', serif; /* Word文档内容保持Calibri字体 */
        }

        /* 隐藏Word文档滚动条但保持滚动功能 */
        .word-document::-webkit-scrollbar {
            width: 0;
            background: transparent;
        }

        .word-document {
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE/Edge */
        }

        .word-header {
            border-bottom: none;
            padding-bottom: 20px;
            margin-bottom: 25px;
            text-align: center;
        }

        .word-title {
            font-size: 20px;
            font-weight: 700;
            color: #1f2937;
            margin-bottom: 8px;
            font-family: 'Calibri', sans-serif;
        }

        .word-subtitle {
            font-size: 14px;
            color: #6b7280;
            font-weight: 400;
            font-style: italic;
        }

        .word-content {
            line-height: 1.8;
            color: #1f2937;
            font-size: 14px;
            font-family: 'Calibri', sans-serif;
        }

        .word-section {
            margin-bottom: 25px;
        }

        .word-section h3 {
            font-size: 16px;
            font-weight: 700;
            color: #1f2937;
            margin-bottom: 12px;
            border-left: none;
            padding-left: 0;
            font-family: 'Calibri', sans-serif;
        }

        .word-section p {
            font-size: 14px;
            margin-bottom: 12px;
            text-align: justify;
            text-indent: 0;
            line-height: 1.8;
        }

        .word-list {
            font-size: 14px;
            margin-left: 20px;
            margin-bottom: 15px;
            line-height: 1.8;
        }

        .word-list li {
            margin-bottom: 8px;
        }

        .highlight {
            background: #fef3c7;
            padding: 1px 3px;
            border-radius: 2px;
        }

        /* Word文档页边距和页面样式 */
        .word-document::before {
            content: '';
            position: absolute;
            top: 0;
            left: 20px;
            right: 20px;
            height: 1px;
            background: #e5e7eb;
        }

        /* 动画效果 */

        .canvas-area {
            width: 100%;
            height: 100%;
            background: transparent;
            position: relative;
        }

        .canvas-placeholder {
            display: none;
        }

        .canvas-icon {
            width: 80px;
            height: 80px;
            background: #f0f0f0;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
            font-size: 32px;
        }

        /* Claude输出容器样式 */
        .claude-output-container {
            position: absolute;
            left: 50%;
            top: 80px;
            width: 48%;
            height: 60vh;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            border: none;
            max-height: 60vh;
            overflow: hidden;
            font-family: 'Calibri', 'Times New Roman', serif;
            padding: 10px;
            cursor: move;
            user-select: none;
            display: none; /* 默认隐藏 */
            z-index: 30; /* Claude容器层级最高 */
        }

        .claude-output-container:hover {
            box-shadow: 0 6px 25px rgba(0, 0, 0, 0.15);
        }

        .claude-output-toolbar {
            background: #f8f9fa;
            border-bottom: 1px solid #e5e7eb;
            padding: 8px 50px 8px 15px;
            font-size: 11px;
            color: #6b7280;
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin: -10px -10px 0 -10px;
        }

        .claude-output-filename {
            font-weight: 500;
            color: #374151;
        }

        .claude-output-filename i {
            color: #667eea; /* Claude紫色图标 */
            margin-right: 6px;
        }

        .claude-toolbar-right {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .claude-output-content {
            padding: 5px;
            height: calc(100% - 50px);
            overflow-y: auto;
            background: white;
            margin: 0;
            box-shadow: none;
            /* 隐藏滚动条但保持滚动功能 */
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE and Edge */
        }

        .claude-output-content::-webkit-scrollbar {
            width: 0;
            background: transparent;
        }

        /* 悬浮对话框 */
        .chat-container {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            z-index: 1000;
            border: 1px solid rgba(0, 0, 0, 0.08);
        }

        .chat-header {
            background: white;
            color: #333;
            padding: 0;
            display: none;
        }

        .chat-header h3 {
            font-size: 16px;
            font-weight: 600;
        }

        .chat-status {
            font-size: 12px;
            opacity: 0.8;
        }

        .chat-messages {
            height: 200px;
            padding: 16px;
            overflow-y: auto;
            background: white;
            transition: height 0.3s ease, opacity 0.3s ease;
        }

        /* 当没有消息时隐藏对话历史区域 */
        .chat-messages.empty {
            height: 0;
            padding: 0;
            opacity: 0;
            overflow: hidden;
        }

        .message {
            margin-bottom: 16px;
            display: flex;
            align-items: flex-start;
        }

        .message.user {
            flex-direction: row-reverse;
        }

        .message-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: 600;
            margin: 0 10px;
            flex-shrink: 0;
        }

        .message.user .message-avatar {
            background: #667eea;
            color: white;
        }

        .message.ai .message-avatar {
            background: #e8ecf3;
            color: #667eea;
        }

        .message-content {
            max-width: 70%;
            padding: 12px 16px;
            border-radius: 18px;
            font-size: 14px;
            line-height: 1.4;
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', 'Helvetica Neue', Helvetica, Arial, sans-serif;
            font-weight: 400;
        }

        .message.user .message-content {
            background: #667eea;
            color: white;
            border-bottom-right-radius: 6px;
        }

        .message.ai .message-content {
            background: white;
            color: #333;
            border-bottom-left-radius: 6px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        /* 输入框区域 */
        .chat-input-container {
            padding: 16px;
            background: white;
            border-top: 1px solid #e5e5e5;
        }

        .chat-input-wrapper {
            display: flex;
            align-items: center;
            background: white;
            border-radius: 25px;
            padding: 12px 16px;
            border: 1px solid #e0e0e0;
            transition: all 0.2s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }

        .chat-input-wrapper:focus-within {
            border-color: #007bff;
            box-shadow: 0 2px 12px rgba(0, 123, 255, 0.15);
        }

        .chat-input {
            flex: 1;
            border: none;
            background: transparent;
            padding: 0;
            font-size: 15px;
            outline: none;
            resize: none;
            min-height: 22px;
            max-height: 100px;
            line-height: 1.4;
            color: #333;
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', 'Helvetica Neue', Helvetica, Arial, sans-serif;
            font-weight: 400;
        }

        .chat-input::placeholder {
            color: #999;
        }

        .send-button {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: #f0f0f0;
            color: #666;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            transition: all 0.2s ease;
            margin-left: 8px;
        }

        .send-button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .send-button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        /* 滚动条样式 */
        .chat-messages::-webkit-scrollbar {
            width: 6px;
        }

        .chat-messages::-webkit-scrollbar-track {
            background: transparent;
        }

        .chat-messages::-webkit-scrollbar-thumb {
            background: #ddd;
            border-radius: 3px;
        }

        .chat-messages::-webkit-scrollbar-thumb:hover {
            background: #bbb;
        }

        /* 响应式设计 */
        @media (max-width: 768px) {
            .chat-container {
                bottom: 20px;
                left: 20px;
                right: 20px;
                width: auto;
                transform: none;
            }
        }

        /* 消息动画效果 */

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message {
            animation: fadeIn 0.3s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Collab 椭圆形滑动开关样式 */
        .collab-toggle {
            position: relative;
            width: 42px;
            height: 20px;
            background: #E5E5EA;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            user-select: none;
            display: inline-flex;
            align-items: center;
            justify-content: flex-start;
        }

        .collab-toggle:hover {
            background: #D1D1D6;
        }

        .collab-toggle.active {
            background: #34C759;
            justify-content: flex-end;
        }

        .collab-toggle.active:hover {
            background: #30B550;
        }

        .collab-toggle-slider {
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: absolute;
            left: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            color: #8E8E93;
        }

        .collab-toggle.active .collab-toggle-slider {
            left: calc(100% - 18px);
            background: white;
            color: #34C759;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        /* 用户协作指示器 */
        .user-collaborator {
            position: absolute;
            top: 8px;
            right: 8px;
            display: none;
            align-items: center;
            gap: 6px;
            background: rgba(0, 122, 204, 0.9);
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 11px;
            z-index: 20;
            animation: slideInFromRight 0.3s ease;
        }

        .user-collaborator.active {
            display: flex;
        }

        .user-avatar {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            font-weight: bold;
        }

        .user-status {
            font-size: 10px;
            opacity: 0.9;
        }

        /* 单元格编辑动画 */
        .cell-editing {
            position: relative;
            background: rgba(0, 122, 204, 0.1) !important;
            border: 2px solid #007acc !important;
            animation: cellPulse 1s ease-in-out infinite alternate;
        }

        @keyframes cellPulse {
            from { box-shadow: 0 0 5px rgba(0, 122, 204, 0.3); }
            to { box-shadow: 0 0 15px rgba(0, 122, 204, 0.6); }
        }

        .typing-cursor {
            display: inline-block;
            width: 1px;
            height: 14px;
            background: #007acc;
            animation: blink 1s step-end infinite;
            margin-left: 1px;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        /* 浮动协作气泡样式 */
        .collaboration-bubble {
            position: absolute;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #ddd;
            border-radius: 16px;
            padding: 6px 12px;
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: #333;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            opacity: 0;
            transform: scale(0.8);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            pointer-events: none;
            white-space: nowrap;
        }
        
        .collaboration-bubble.active {
            opacity: 1;
            transform: scale(1);
            pointer-events: auto;
        }
        
        .collaboration-bubble::after {
            content: '';
            position: absolute;
            bottom: -6px;
            left: 12px;
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-top: 6px solid rgba(255, 255, 255, 0.95);
            filter: drop-shadow(0 1px 1px rgba(0, 0, 0, 0.1));
        }
        
        .bubble-avatar {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #0078d4;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
        }
        
        .bubble-name {
            font-weight: 500;
            color: #333;
        }
        
        .bubble-status {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #00c851;
            animation: bubble-pulse 1.5s infinite;
        }
        
        .bubble-status.selecting {
            background: #ffbb33;
            animation: none;
        }
        
        .bubble-status.typing {
            background: #00c851;
            animation: bubble-pulse 1.5s infinite;
        }
        
        .bubble-status.thinking {
            background: #667eea;
            animation: bubble-pulse 1.5s infinite;
        }
        
        @keyframes bubble-pulse {
            0%, 100% {
                opacity: 1;
                transform: scale(1);
            }
            50% {
                opacity: 0.6;
                transform: scale(1.2);
            }
        }
        
        /* 气泡浮动动画 */
        .collaboration-bubble.floating {
            animation: bubble-float 3s ease-in-out infinite;
        }
        
        @keyframes bubble-float {
            0%, 100% {
                transform: scale(1) translateY(0px);
            }
            50% {
                transform: scale(1) translateY(-2px);
            }
        }

        /* Word协作气泡特定样式 */
        .word-collaboration-bubble {
            position: absolute;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #ddd;
            border-radius: 16px;
            padding: 6px 12px;
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: #333;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            opacity: 0;
            transform: scale(0.8);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            pointer-events: none;
            white-space: nowrap;
        }
        
        .word-collaboration-bubble.active {
            opacity: 1;
            transform: scale(1);
            pointer-events: auto;
        }
        
        .word-collaboration-bubble::after {
            content: '';
            position: absolute;
            left: 20px; /* 箭头距离气泡左边缘20px */
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            filter: drop-shadow(0 1px 1px rgba(0, 0, 0, 0.1));
        }
        
        /* 默认箭头指向下方（气泡在元素上方时） */
        .word-collaboration-bubble::after {
            bottom: -6px;
            border-top: 6px solid rgba(255, 255, 255, 0.95);
        }
        
        /* 当气泡在元素下方时，箭头指向上方 */
        .word-collaboration-bubble[style*="--arrow-direction: up"]::after {
            top: -6px;
            bottom: auto;
            border-top: none;
            border-bottom: 6px solid rgba(255, 255, 255, 0.95);
        }
        
        .word-collaboration-bubble .bubble-avatar {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #28a745; /* Yuecong使用绿色头像 */
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
        }
        
        .word-collaboration-bubble.floating {
            animation: bubble-float 3s ease-in-out infinite;
        }

        /* Claude协作气泡特定样式 */
        .claude-collaboration-bubble {
            position: absolute;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #ddd;
            border-radius: 16px;
            padding: 6px 12px;
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: #333;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            opacity: 0;
            transform: scale(0.8);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            pointer-events: none;
            white-space: nowrap;
            max-width: 200px;
        }
        
        .claude-collaboration-bubble.active {
            opacity: 1;
            transform: scale(1);
            pointer-events: auto;
        }
        
        .claude-collaboration-bubble::after {
            content: '';
            position: absolute;
            right: 20px; /* 箭头距离气泡右边缘20px */
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            filter: drop-shadow(0 1px 1px rgba(0, 0, 0, 0.1));
        }
        
        /* 默认箭头指向下方（气泡在上方时） */
        .claude-collaboration-bubble::after {
            bottom: -6px;
            border-top: 6px solid rgba(255, 255, 255, 0.95);
        }
        
        /* 当气泡在下方时，箭头指向上方 */
        .claude-collaboration-bubble[style*="--arrow-direction: up"]::after {
            top: -6px;
            bottom: auto;
            border-top: none;
            border-bottom: 6px solid rgba(255, 255, 255, 0.95);
        }
        
        .claude-collaboration-bubble .bubble-avatar {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea; /* Claude紫色头像 */
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
        }
        
        .claude-collaboration-bubble.floating {
            animation: bubble-float 3s ease-in-out infinite;
        }

        /* Word文档光标动画 */
        .typing-cursor {
            display: inline-block;
            width: 1px;
            height: 16px;
            background-color: #333;
            margin-left: 1px;
        }

        @keyframes cursor-blink {
            0%, 50% {
                opacity: 1;
            }
            51%, 100% {
                opacity: 0;
            }
        }

        @keyframes slideInFromRight {
            from {
                opacity: 0;
                transform: translateX(20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
        
        /* 全局动画控制开关 */
        .global-animation-control {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 9999;
            background: white;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            padding: 8px 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            color: #374151;
            transition: all 0.3s ease;
        }
        
        .global-animation-control:hover {
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
            transform: translateY(-2px);
        }
        
        .global-animation-toggle {
            position: relative;
            width: 48px;
            height: 24px;
            background: #d1d5db;
            border-radius: 12px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        
        .global-animation-toggle.active {
            background: #10b981;
        }
        
        .global-animation-toggle .slider {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .global-animation-toggle.active .slider {
            transform: translateX(24px);
        }
        
        .global-animation-control .icon {
            font-size: 16px;
            color: #667eea;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Canvas区域 -->
        <div class="canvas-container">
            <div class="canvas-area">
                <div class="canvas-placeholder">
                    <div class="canvas-icon">🎨</div>
                    <p>您的创作画布</p>
                    <p style="font-size: 14px; margin-top: 8px; opacity: 0.7;">开始与AI对话来创建设计</p>
                </div>
            </div>

            <!-- Excel表格 -->
            <div class="excel-container">
                <div class="document-checkbox" data-document="excel">
                    <input type="checkbox" id="excel-checkbox" class="checkbox-input">
                    <label for="excel-checkbox" class="checkbox-label">
                        <i class="fas fa-check"></i>
                    </label>
                </div>
                <!-- 调整大小手柄 -->
                <div class="resize-handle resize-handle-se"></div>
                <div class="resize-handle resize-handle-e"></div>
                <div class="resize-handle resize-handle-s"></div>
                <div class="excel-toolbar">
                    <div class="excel-filename"><i class="fas fa-file-excel"></i> PPT_Template_Search_Data.xlsx</div>
                    <div style="display: flex; align-items: center; gap: 12px;">
                        <div class="collab-toggle" id="collab-toggle">
                            <div class="collab-toggle-slider">
                                <i class="fas fa-users"></i>
                            </div>
                        </div>
                        <div>Microsoft Excel</div>
                    </div>
                </div>
                <div class="excel-content">
                    <div class="excel-title">PPT Template Search Data</div>
                    <table class="excel-table">
                    <thead>
                        <tr>
                            <th>Search Query</th>
                            <th>Frequency</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td class="search-query">business presentation template</td>
                            <td class="search-frequency">2,847</td>
                        </tr>
                        <tr>
                            <td class="search-query">corporate slides design</td>
                            <td class="search-frequency">2,156</td>
                        </tr>
                        <tr>
                            <td class="search-query">marketing pitch deck</td>
                            <td class="search-frequency">1,923</td>
                        </tr>
                        <tr>
                            <td class="search-query">modern powerpoint template</td>
                            <td class="search-frequency">1,784</td>
                        </tr>
                        <tr>
                            <td class="search-query">startup pitch presentation</td>
                            <td class="search-frequency">1,567</td>
                        </tr>
                        <tr>
                            <td class="search-query">financial report template</td>
                            <td class="search-frequency">1,432</td>
                        </tr>
                        <tr>
                            <td class="search-query">project proposal slides</td>
                            <td class="search-frequency">1,298</td>
                        </tr>
                        <tr>
                            <td class="search-query">creative presentation design</td>
                            <td class="search-frequency">1,189</td>
                        </tr>
                        <tr>
                            <td class="search-query">annual report template</td>
                            <td class="search-frequency">1,067</td>
                        </tr>
                        <tr>
                            <td class="search-query">sales presentation template</td>
                            <td class="search-frequency">945</td>
                        </tr>
                        <tr>
                            <td class="search-query">educational slides template</td>
                            <td class="search-frequency">876</td>
                        </tr>
                        <tr>
                            <td class="search-query">conference presentation</td>
                            <td class="search-frequency">798</td>
                        </tr>
                        <tr>
                            <td class="search-query">timeline presentation template</td>
                            <td class="search-frequency">723</td>
                        </tr>
                        <tr>
                            <td class="search-query">data visualization slides</td>
                            <td class="search-frequency">654</td>
                        </tr>
                        <tr>
                            <td class="search-query">team presentation template</td>
                            <td class="search-frequency">587</td>
                        </tr>
                        <tr>
                            <td class="search-query">product launch presentation</td>
                            <td class="search-frequency">512</td>
                        </tr>
                        <tr>
                            <td class="search-query">strategy presentation template</td>
                            <td class="search-frequency">445</td>
                        </tr>
                        <tr>
                            <td class="search-query">training presentation slides</td>
                            <td class="search-frequency">378</td>
                        </tr>
                        <tr>
                            <td class="search-query">investor pitch template</td>
                            <td class="search-frequency">321</td>
                        </tr>
                        <tr>
                            <td class="search-query">minimal presentation design</td>
                            <td class="search-frequency">267</td>
                        </tr>
                    </tbody>
                </table>
                </div>
            </div>

            <!-- Word文档 -->
            <div class="word-container">
                <div class="document-checkbox" data-document="word">
                    <input type="checkbox" id="word-checkbox" class="checkbox-input">
                    <label for="word-checkbox" class="checkbox-label">
                        <i class="fas fa-check"></i>
                    </label>
                </div>
                <!-- 调整大小手柄 -->
                <div class="resize-handle resize-handle-se"></div>
                <div class="resize-handle resize-handle-e"></div>
                <div class="resize-handle resize-handle-s"></div>
                <div class="word-toolbar">
                    <div class="word-filename"><i class="fas fa-file-word"></i> Research_Report.docx</div>
                    <div class="word-toolbar-right">
                        <div class="collab-toggle" id="word-collab-toggle">
                            <div class="collab-toggle-slider">
                                <i class="fas fa-users"></i>
                            </div>
                        </div>
                        <span>Microsoft Word</span>
                    </div>
                </div>
                
                <div class="word-document">
                    <div class="word-header">
                        <div class="word-title">PPT Template User Research Report</div>
                        <div class="word-subtitle">Market Analysis & User Behavior Study | December 2024</div>
                    </div>

                    <div class="word-content">
                        <div class="word-section">
                            <h3>Executive Summary</h3>
                            <p>This comprehensive user research report analyzes the current market trends and user preferences for PowerPoint templates. Based on extensive data collection from over <span class="highlight">50,000 users</span> across different industries, we identify key patterns in template usage and design preferences.</p>
                        </div>

                        <div class="word-section">
                            <h3>Key Findings</h3>
                            <ul class="word-list">
                                <li><strong>Business Templates:</strong> Account for 68% of all searches</li>
                                <li><strong>Visual Design:</strong> Modern, clean layouts preferred by 84% of users</li>
                                <li><strong>Color Schemes:</strong> Professional blue/grey combinations dominate</li>
                                <li><strong>Industry Focus:</strong> Corporate and startup presentations lead demand</li>
                            </ul>
                        </div>

                        <div class="word-section">
                            <h3>User Demographics</h3>
                            <p>Primary users consist of business professionals (45%), educators (23%), consultants (18%), and entrepreneurs (14%). The majority of users are aged between 25-45 years and work in corporate environments requiring regular presentation creation.</p>
                        </div>

                        <div class="word-section">
                            <h3>Design Preferences</h3>
                            <p>Users consistently favor templates with <span class="highlight">minimalist designs</span>, clear typography, and structured layouts. Data visualization capabilities and infographic elements are increasingly important, with 72% of users seeking templates that support chart integration.</p>
                        </div>

                        <div class="word-section">
                            <h3>Market Opportunities</h3>
                            <ul class="word-list">
                                <li>Industry-specific template collections</li>
                                <li>Interactive presentation elements</li>
                                <li>AI-powered design suggestions</li>
                                <li>Collaborative editing features</li>
                            </ul>
                        </div>

                        <div class="word-section">
                            <h3>Recommendations</h3>
                            <p>Based on our research, we recommend focusing on creating versatile business templates with customizable color schemes and enhanced data visualization tools. Priority should be given to developing templates for emerging sectors like technology startups and sustainable business presentations.</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Claude任务输出容器 -->
            <div class="claude-output-container" id="claudeOutputContainer">
                <div class="document-checkbox" data-document="claude">
                    <input type="checkbox" id="claude-checkbox" class="checkbox-input">
                    <label for="claude-checkbox" class="checkbox-label">
                        <i class="fas fa-check"></i>
                    </label>
                </div>
                <!-- 调整大小手柄 -->
                <div class="resize-handle resize-handle-se"></div>
                <div class="resize-handle resize-handle-e"></div>
                <div class="resize-handle resize-handle-s"></div>
                <div class="claude-output-toolbar">
                    <div class="claude-output-filename">
                        <i class="fas fa-robot"></i> 
                        <span id="claudeTaskTitle">Claude Task Output</span>
                    </div>
                    <div class="claude-toolbar-right">
                        <span>Claude Sonnet 4</span>
                    </div>
                </div>
                
                <div class="claude-output-content" id="claudeOutputContent">
                    <div style="text-align: center; padding: 40px; color: #6b7280;">
                        <i class="fas fa-robot" style="font-size: 32px; margin-bottom: 15px; color: #667eea;"></i>
                        <p>Claude will display task results here</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- 悬浮对话框 -->
        <div class="chat-container">
            <div class="chat-messages" id="chatMessages">
                <!-- 消息将通过JavaScript动态添加 -->
            </div>

            <div class="chat-input-container">
                <div class="chat-input-wrapper">
                    <textarea 
                        class="chat-input" 
                        id="chatInput" 
                        placeholder="Ask Clippy Anything"
                        rows="1"></textarea>
                    <button class="send-button" id="sendButton">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 基础JavaScript功能
        const chatMessages = document.getElementById('chatMessages');
        const chatInput = document.getElementById('chatInput');
        const sendButton = document.getElementById('sendButton');
        
        // 存储对话历史
        let conversationHistory = [];
        // 环境自适应的API基础URL
        const API_BASE_URL = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' 
            ? 'http://localhost:5000' 
            : window.location.origin;

        // ===== Excel协作动画系统 =====
        class ExcelCollaborationAnimator {
            constructor() {
                this.isActive = false;
                this.animationInterval = null;
                this.currentStep = 0;
                this.collaborationBubble = null;
                
                // 添加状态管理
                this.activeTimeouts = new Set();
                this.animatingCells = new Set();
                this.isAnimationRunning = false;
                
                // 动画序列配置
                this.animationSequence = [
                    { action: 'selectCell', target: 'tbody tr:nth-child(2) td:nth-child(1)', duration: 1000, text: '' },
                    { action: 'typeText', target: 'tbody tr:nth-child(2) td:nth-child(1)', duration: 2000, text: 'AI assistant template' },
                    { action: 'pause', duration: 800 },
                    { action: 'selectCell', target: 'tbody tr:nth-child(2) td:nth-child(2)', duration: 1000, text: '' },
                    { action: 'editNumber', target: 'tbody tr:nth-child(2) td:nth-child(2)', duration: 1500, newValue: '3156' },
                    { action: 'pause', duration: 1200 },
                    { action: 'selectCell', target: 'tbody tr:nth-child(3) td:nth-child(1)', duration: 1000, text: '' },
                    { action: 'typeText', target: 'tbody tr:nth-child(3) td:nth-child(1)', duration: 2000, text: 'modern AI dashboard' },
                    { action: 'pause', duration: 800 },
                    { action: 'selectCell', target: 'tbody tr:nth-child(3) td:nth-child(2)', duration: 1000, text: '' },
                    { action: 'editNumber', target: 'tbody tr:nth-child(3) td:nth-child(2)', duration: 1500, newValue: '2389' }
                ];
                
                this.init();
            }
            
            init() {
                const toggleBtn = document.getElementById('collab-toggle');
                const excelContainer = document.querySelector('.excel-container');
                
                // 创建浮动气泡
                this.createCollaborationBubble();
                
                // 切换按钮事件
                toggleBtn.addEventListener('click', () => {
                    this.toggle();
                });
            }
            
            createCollaborationBubble() {
                const excelContainer = document.querySelector('.excel-container');
                
                this.collaborationBubble = document.createElement('div');
                this.collaborationBubble.className = 'collaboration-bubble';
                this.collaborationBubble.innerHTML = `
                    <div class="bubble-avatar">A</div>
                    <span class="bubble-name">Aibo</span>
                    <div class="bubble-status selecting"></div>
                `;
                
                excelContainer.appendChild(this.collaborationBubble);
            }
            
            toggle() {
                const toggleBtn = document.getElementById('collab-toggle');
                
                this.isActive = !this.isActive;
                
                if (this.isActive) {
                    toggleBtn.classList.add('active');
                    this.startAnimation();
                } else {
                    toggleBtn.classList.remove('active');
                    this.stopAnimation();
                    this.hideBubble();
                }
            }
            
            startAnimation() {
                if (this.animationInterval) return;
                
                this.currentStep = 0;
                this.runAnimationSequence();
            }
            
            stopAnimation() {
                if (this.animationInterval) {
                    clearTimeout(this.animationInterval);
                    this.animationInterval = null;
                }
                
                // 清理所有活动的setTimeout
                this.activeTimeouts.forEach(timeoutId => {
                    clearTimeout(timeoutId);
                });
                this.activeTimeouts.clear();
                
                // 重置状态
                this.isAnimationRunning = false;
                this.animatingCells.clear();
                
                // 强制清理所有动画效果
                this.clearAllAnimations();
            }
            
            runAnimationSequence() {
                if (!this.isActive || this.isAnimationRunning) return;
                
                // 设置运行状态标志
                this.isAnimationRunning = true;
                
                const step = this.animationSequence[this.currentStep];
                if (!step) {
                    // 重置到开始
                    this.currentStep = 0;
                    this.isAnimationRunning = false;
                    this.animationInterval = setTimeout(() => this.runAnimationSequence(), 3000);
                    return;
                }
                
                this.executeStep(step).then(() => {
                    this.currentStep++;
                    this.isAnimationRunning = false;
                    this.animationInterval = setTimeout(() => this.runAnimationSequence(), step.duration);
                }).catch(() => {
                    // 出错时重置状态
                    this.isAnimationRunning = false;
                    this.currentStep = 0;
                });
            }
            
            async executeStep(step) {
                const excelTable = document.querySelector('.excel-table');
                if (!excelTable) return;
                
                switch (step.action) {
                    case 'selectCell':
                        this.selectCell(excelTable.querySelector(step.target));
                        break;
                    case 'typeText':
                        await this.typeInCell(excelTable.querySelector(step.target), step.text);
                        break;
                    case 'editNumber':
                        await this.editNumberInCell(excelTable.querySelector(step.target), step.newValue);
                        break;
                    case 'pause':
                        // 什么也不做，只是等待
                        break;
                }
            }
            
            selectCell(cell) {
                if (!cell) return;
                
                // 清除之前的选中状态
                document.querySelectorAll('.cell-editing').forEach(c => {
                    c.classList.remove('cell-editing');
                });
                
                // 选中新单元格
                cell.classList.add('cell-editing');
                
                // 显示并定位气泡
                this.showBubbleAtCell(cell, 'selecting');
            }
            
            showBubbleAtCell(targetCell, status = 'selecting') {
                if (!targetCell || !this.collaborationBubble) return;
                
                const excelContainer = document.querySelector('.excel-container');
                const cellRect = targetCell.getBoundingClientRect();
                const containerRect = excelContainer.getBoundingClientRect();
                
                // 计算相对于容器的位置
                let x = cellRect.left - containerRect.left + cellRect.width + 10;
                let y = cellRect.top - containerRect.top - 10;
                
                // 边界检测和调整
                const bubbleWidth = 90; // 估算气泡宽度
                const bubbleHeight = 32; // 估算气泡高度
                
                if (x + bubbleWidth > excelContainer.clientWidth) {
                    x = cellRect.left - containerRect.left - bubbleWidth - 10; // 移到左侧
                }
                if (y < 0) {
                    y = cellRect.bottom - containerRect.top + 5; // 移到下方
                    // 调整箭头指向
                    this.collaborationBubble.style.setProperty('--arrow-direction', 'up');
                } else {
                    this.collaborationBubble.style.setProperty('--arrow-direction', 'down');
                }
                
                // 设置位置
                this.collaborationBubble.style.left = x + 'px';
                this.collaborationBubble.style.top = y + 'px';
                
                // 更新状态
                this.updateBubbleStatus(status);
                
                // 显示气泡
                this.collaborationBubble.classList.add('active');
                this.collaborationBubble.classList.add('floating');
            }
            
            updateBubbleStatus(status) {
                const statusDot = this.collaborationBubble.querySelector('.bubble-status');
                statusDot.className = `bubble-status ${status}`;
            }
            
            hideBubble() {
                if (this.collaborationBubble) {
                    this.collaborationBubble.classList.remove('active');
                    this.collaborationBubble.classList.remove('floating');
                }
            }
            
            async typeInCell(cell, text) {
                if (!cell || !text) return;
                
                // 检查并防止重复动画
                const cellKey = cell.cellIndex + '_' + cell.parentNode.rowIndex;
                if (this.animatingCells.has(cellKey)) {
                    console.warn('Cell is already animating, skipping...');
                    return;
                }
                
                // 强制清理该单元格的所有残留
                this.forceClearCell(cell);
                
                // 清空单元格内容 - 这行很重要！
                cell.innerHTML = '';
                
                // 标记单元格为动画中
                this.animatingCells.add(cellKey);
                
                // 更新气泡状态为输入中
                this.updateBubbleStatus('typing');
                
                return new Promise((resolve) => {
                    let i = 0;
                    const cursor = document.createElement('span');
                    cursor.className = 'typing-cursor';
                    
                    const typeChar = () => {
                        // 检查动画是否应该继续
                        if (!this.isActive || !this.animatingCells.has(cellKey)) {
                            cursor.remove();
                            this.animatingCells.delete(cellKey);
                            resolve();
                            return;
                        }
                        
                        if (i < text.length) {
                            cell.textContent += text.charAt(i);
                            // 移除旧光标再添加新光标
                            const oldCursors = cell.querySelectorAll('.typing-cursor');
                            oldCursors.forEach(c => c.remove());
                            cell.appendChild(cursor);
                            i++;
                            
                            // 记录setTimeout ID
                            const timeoutId = setTimeout(typeChar, 100);
                            this.activeTimeouts.add(timeoutId);
                        } else {
                            cursor.remove();
                            this.animatingCells.delete(cellKey);
                            this.updateBubbleStatus('selecting');
                            resolve();
                        }
                    };
                    
                    cell.appendChild(cursor);
                    const initialTimeoutId = setTimeout(typeChar, 200);
                    this.activeTimeouts.add(initialTimeoutId);
                });
            }
            
            async editNumberInCell(cell, newValue) {
                if (!cell || !newValue) return;
                
                // 检查并防止重复动画
                const cellKey = cell.cellIndex + '_' + cell.parentNode.rowIndex;
                if (this.animatingCells.has(cellKey)) {
                    console.warn('Cell is already animating, skipping...');
                    return;
                }
                
                // 强制清理该单元格的所有残留
                this.forceClearCell(cell);
                
                // 标记单元格为动画中
                this.animatingCells.add(cellKey);
                
                return new Promise((resolve) => {
                    // 将数字转换为千分位格式
                    const formattedValue = parseInt(newValue).toLocaleString();
                    
                    // 更新气泡状态为选择中
                    this.updateBubbleStatus('selecting');
                    
                    // 第一阶段：全选效果（模拟Ctrl+A）
                    cell.style.backgroundColor = '#0078d4';
                    cell.style.color = 'white';
                    
                    const selectTimeoutId = setTimeout(() => {
                        // 检查动画是否应该继续
                        if (!this.isActive || !this.animatingCells.has(cellKey)) {
                            this.resetCellStyle(cell);
                            this.animatingCells.delete(cellKey);
                            resolve();
                            return;
                        }
                        
                        // 第二阶段：删除内容（模拟Delete键）
                        cell.textContent = '';
                        this.resetCellStyle(cell);
                        
                        // 更新气泡状态为输入中
                        this.updateBubbleStatus('typing');
                        
                        // 第三阶段：逐位输入新数字（包括逗号）
                        let i = 0;
                        const cursor = document.createElement('span');
                        cursor.className = 'typing-cursor';
                        
                        const typeDigit = () => {
                            // 检查动画是否应该继续
                            if (!this.isActive || !this.animatingCells.has(cellKey)) {
                                cursor.remove();
                                this.animatingCells.delete(cellKey);
                                resolve();
                                return;
                            }
                            
                            if (i < formattedValue.length) {
                                cell.textContent += formattedValue.charAt(i);
                                // 移除旧光标再添加新光标
                                const oldCursors = cell.querySelectorAll('.typing-cursor');
                                oldCursors.forEach(c => c.remove());
                                cell.appendChild(cursor);
                                i++;
                                
                                const digitTimeoutId = setTimeout(typeDigit, 150);
                                this.activeTimeouts.add(digitTimeoutId);
                            } else {
                                cursor.remove();
                                this.animatingCells.delete(cellKey);
                                this.updateBubbleStatus('selecting');
                                resolve();
                            }
                        };
                        
                        cell.appendChild(cursor);
                        const initialDigitTimeoutId = setTimeout(typeDigit, 300);
                        this.activeTimeouts.add(initialDigitTimeoutId);
                        
                    }, 500);
                    
                    this.activeTimeouts.add(selectTimeoutId);
                });
            }
            
            clearAllAnimations() {
                // 清除所有动画效果
                document.querySelectorAll('.cell-editing').forEach(cell => {
                    cell.classList.remove('cell-editing');
                    this.resetCellStyle(cell);
                });
                
                // 强制清理所有单元格
                document.querySelectorAll('td').forEach(cell => {
                    this.forceClearCell(cell);
                });
                
                // 重置状态
                this.animatingCells.clear();
            }
            
            forceClearCell(cell) {
                // 移除所有光标元素
                const cursors = cell.querySelectorAll('.typing-cursor');
                cursors.forEach(cursor => cursor.remove());
                
                // 重置样式
                this.resetCellStyle(cell);
            }
            
            resetCellStyle(cell) {
                cell.style.backgroundColor = '';
                cell.style.color = '';
            }
        }
        
        // ===== Word协作动画系统 =====
        class WordCollaborationAnimator {
            constructor() {
                this.isActive = false;
                this.animationInterval = null;
                this.currentStep = 0;
                this.collaborationBubble = null;
                
                // 状态管理
                this.activeTimeouts = new Set();
                this.isAnimationRunning = false;
                this.currentBulletIndex = 0;
                
                // 要插入的bullet point内容
                this.bulletPoints = [
                    'Interactive Elements: Users increasingly prefer templates with interactive features like clickable charts and embedded forms',
                    'Mobile Optimization: 76% of users access presentations on mobile devices, requiring responsive template designs',
                    'Brand Consistency: Companies seek templates that can easily incorporate their brand colors and logos while maintaining professional aesthetics'
                ];
                
                this.init();
            }
            
            init() {
                const toggleBtn = document.getElementById('word-collab-toggle');
                const wordContainer = document.querySelector('.word-container');
                
                // 创建协作气泡
                this.createCollaborationBubble();
                
                // 切换按钮事件
                toggleBtn.addEventListener('click', () => {
                    this.toggle();
                });
            }
            
            createCollaborationBubble() {
                const wordContainer = document.querySelector('.word-container');
                
                this.collaborationBubble = document.createElement('div');
                this.collaborationBubble.className = 'word-collaboration-bubble';
                this.collaborationBubble.innerHTML = `
                    <div class="bubble-avatar">Y</div>
                    <span class="bubble-name">Yuecong</span>
                    <div class="bubble-status selecting"></div>
                `;
                
                wordContainer.appendChild(this.collaborationBubble);
            }
            
            toggle() {
                const toggleBtn = document.getElementById('word-collab-toggle');
                
                this.isActive = !this.isActive;
                
                if (this.isActive) {
                    toggleBtn.classList.add('active');
                    this.startAnimation();
                } else {
                    toggleBtn.classList.remove('active');
                    this.stopAnimation();
                    this.hideBubble();
                }
            }
            
            startAnimation() {
                if (this.animationInterval) return;
                
                this.currentBulletIndex = 0;
                this.runAnimationSequence();
            }
            
            stopAnimation() {
                if (this.animationInterval) {
                    clearTimeout(this.animationInterval);
                    this.animationInterval = null;
                }
                
                // 清理所有活动的timeout
                this.activeTimeouts.forEach(timeoutId => {
                    clearTimeout(timeoutId);
                });
                this.activeTimeouts.clear();
                
                // 重置状态
                this.isAnimationRunning = false;
                
                // 清理动画效果
                this.clearAllAnimations();
            }
            
            runAnimationSequence() {
                if (!this.isActive || this.isAnimationRunning) return;
                
                this.isAnimationRunning = true;
                
                if (this.currentBulletIndex >= this.bulletPoints.length) {
                    // 循环重置：清空之前添加的bullet points
                    this.clearAddedBulletPoints();
                    this.currentBulletIndex = 0;
                    this.isAnimationRunning = false;
                    // 清空后稍等一下再开始下一轮
                    this.animationInterval = setTimeout(() => this.runAnimationSequence(), 3000);
                    return;
                }
                
                this.insertBulletPoint(this.currentBulletIndex).then(() => {
                    this.currentBulletIndex++;
                    this.isAnimationRunning = false;
                    // 短暂停顿后继续下一个bullet point
                    this.animationInterval = setTimeout(() => this.runAnimationSequence(), 2000);
                }).catch(() => {
                    this.isAnimationRunning = false;
                    this.currentBulletIndex = 0;
                });
            }
            
            async insertBulletPoint(index) {
                const keyFindingsList = document.querySelector('.word-list');
                if (!keyFindingsList) return;
                
                const bulletText = this.bulletPoints[index];
                
                // 创建新的li元素并添加标记
                const newBullet = document.createElement('li');
                newBullet.classList.add('yuecong-added-bullet'); // 添加标记类
                
                // 插入到第一个li之后
                const firstBullet = keyFindingsList.querySelector('li');
                if (firstBullet && firstBullet.nextSibling) {
                    keyFindingsList.insertBefore(newBullet, firstBullet.nextSibling);
                } else {
                    keyFindingsList.appendChild(newBullet);
                }
                
                // 显示气泡并定位到新bullet point
                this.showBubbleAtElement(newBullet, 'typing');
                
                // 逐字输入文本
                await this.typeInElement(newBullet, bulletText);
                
                // 输入完成后更新状态
                this.updateBubbleStatus('selecting');
                
                // 短暂停顿
                await this.delay(800);
            }
            
            async typeInElement(element, text) {
                return new Promise((resolve) => {
                    let i = 0;
                    const cursor = document.createElement('span');
                    cursor.className = 'typing-cursor';
                    cursor.style.animation = 'cursor-blink 1s infinite';
                    
                    const typeChar = () => {
                        if (!this.isActive) {
                            cursor.remove();
                            resolve();
                            return;
                        }
                        
                        if (i < text.length) {
                            // 移除光标，添加字符，重新添加光标
                            cursor.remove();
                            element.textContent += text.charAt(i);
                            element.appendChild(cursor);
                            i++;
                            
                            const timeoutId = setTimeout(typeChar, 50); // 快速输入
                            this.activeTimeouts.add(timeoutId);
                        } else {
                            cursor.remove();
                            resolve();
                        }
                    };
                    
                    // 添加光标开始输入
                    element.appendChild(cursor);
                    const initialTimeoutId = setTimeout(typeChar, 200);
                    this.activeTimeouts.add(initialTimeoutId);
                });
            }
            
            showBubbleAtElement(targetElement, status = 'selecting') {
                if (!targetElement || !this.collaborationBubble) return;
                
                const wordContainer = document.querySelector('.word-container');
                const elementRect = targetElement.getBoundingClientRect();
                const containerRect = wordContainer.getBoundingClientRect();
                
                // 将气泡放在元素上方，水平居左对齐
                const bubbleWidth = 100;
                const bubbleHeight = 32;
                
                // 计算水平位置（左对齐到bullet point的左边缘）
                let x = elementRect.left - containerRect.left;
                
                // 计算垂直位置（在元素上方）
                let y = elementRect.top - containerRect.top - bubbleHeight - 10;
                
                // 边界检测和调整
                // 确保气泡不超出容器左边界
                if (x < 10) {
                    x = 10;
                }
                // 确保气泡不超出容器右边界
                if (x + bubbleWidth > wordContainer.clientWidth - 10) {
                    x = wordContainer.clientWidth - bubbleWidth - 10;
                }
                
                // 如果上方空间不够，放到下方
                if (y < 10) {
                    y = elementRect.bottom - containerRect.top + 10;
                    // 调整箭头指向（上方）
                    this.collaborationBubble.style.setProperty('--arrow-direction', 'up');
                } else {
                    // 设置箭头指向（下方）
                    this.collaborationBubble.style.setProperty('--arrow-direction', 'down');
                }
                
                // 设置位置
                this.collaborationBubble.style.left = x + 'px';
                this.collaborationBubble.style.top = y + 'px';
                
                // 更新状态
                this.updateBubbleStatus(status);
                
                // 显示气泡
                this.collaborationBubble.classList.add('active');
                this.collaborationBubble.classList.add('floating');
            }
            
            updateBubbleStatus(status) {
                const statusDot = this.collaborationBubble.querySelector('.bubble-status');
                statusDot.className = `bubble-status ${status}`;
            }
            
            hideBubble() {
                if (this.collaborationBubble) {
                    this.collaborationBubble.classList.remove('active');
                    this.collaborationBubble.classList.remove('floating');
                }
            }
            
            clearAddedBulletPoints() {
                // 移除所有Yuecong添加的bullet points
                const addedBullets = document.querySelectorAll('.yuecong-added-bullet');
                addedBullets.forEach(bullet => {
                    bullet.remove();
                });
            }
            
            clearAllAnimations() {
                // 移除所有光标
                document.querySelectorAll('.typing-cursor').forEach(cursor => {
                    cursor.remove();
                });
                
                // 同时清空添加的bullet points（停止动画时）
                this.clearAddedBulletPoints();
            }
            
            delay(ms) {
                return new Promise(resolve => {
                    const timeoutId = setTimeout(resolve, ms);
                    this.activeTimeouts.add(timeoutId);
                });
            }
        }
        
        // ===== Claude AI协作动画系统 =====
        class ClaudeAIAnimator {
            constructor() {
                this.isActive = true; // 默认动画为打开状态
                this.animationInterval = null;
                this.currentStep = 0;
                this.collaborationBubble = null;
                this.hasPlayedOnce = false; // 新增：标记是否已经播放过一次
                
                // 状态管理
                this.activeTimeouts = new Set();
                this.isAnimationRunning = false;
                this.currentContent = '';
                this.targetContainer = null;
                this.lastScrollHeight = 0; // 记录上次滚动高度，防止重复滚动
                
                // AI思考阶段内容
                this.thinkingSteps = [
                    '正在分析用户需求...',
                    '设计页面布局和结构...',
                    '编写HTML标签...',
                    '添加CSS样式...',
                    '优化用户体验...',
                    '最终检查和完善...'
                ];
                
                this.init();
            }
            
            init() {
                const claudeContainer = document.querySelector('.claude-output-container');
                
                // 创建协作气泡
                this.createCollaborationBubble();
                
                // 设置全局动画控制
                this.setupGlobalAnimationControl();
                
                // 动画默认开启，无需切换按钮
                console.log('Claude动画系统已初始化，默认开启');
            }
            
            setupGlobalAnimationControl() {
                const globalToggle = document.getElementById('globalAnimationToggle');
                if (globalToggle) {
                    globalToggle.addEventListener('click', () => {
                        this.isActive = !this.isActive;
                        globalToggle.classList.toggle('active', this.isActive);
                        
                        // 更新图标和标签
                        const control = globalToggle.closest('.global-animation-control');
                        const icon = control.querySelector('.icon');
                        const label = control.querySelector('.label');
                        
                        if (this.isActive) {
                            icon.className = 'fas fa-play icon';
                            label.textContent = 'Claude动画';
                            console.log('Claude动画已开启');
                        } else {
                            icon.className = 'fas fa-pause icon';
                            label.textContent = 'Claude动画';
                            this.stopAnimation();
                            this.hideBubble();
                            console.log('Claude动画已关闭');
                        }
                    });
                }
            }
            
            createCollaborationBubble() {
                const claudeContainer = document.querySelector('.claude-output-container');
                
                this.collaborationBubble = document.createElement('div');
                this.collaborationBubble.className = 'claude-collaboration-bubble';
                this.collaborationBubble.innerHTML = `
                    <div class="bubble-avatar">C</div>
                    <span class="bubble-name">Claude</span>
                    <div class="bubble-status selecting"></div>
                `;
                
                claudeContainer.appendChild(this.collaborationBubble);
            }
            
            toggle() {
                this.isActive = !this.isActive;
                
                if (this.isActive) {
                    console.log('Claude动画已启用');
                    this.startAnimation();
                } else {
                    console.log('Claude动画已停用');
                    this.stopAnimation();
                    this.hideBubble();
                }
            }
            
            startAnimation() {
                if (this.animationInterval) return;
                
                // 如果已经播放过一次，则不再自动播放
                if (this.hasPlayedOnce) {
                    console.log('Claude动画已播放过，等待新内容或手动触发...');
                    return;
                }
                
                // 检查是否有内容可以渲染
                const contentContainer = document.getElementById('claudeOutputContent');
                const iframe = contentContainer.querySelector('iframe');
                
                if (iframe && iframe.srcdoc) {
                    this.currentContent = iframe.srcdoc;
                    this.targetContainer = iframe;
                    this.runProgressiveRendering();
                } else {
                    // 如果没有内容，显示思考过程
                    this.runThinkingAnimation();
                }
            }
            
            stopAnimation() {
                if (this.animationInterval) {
                    clearTimeout(this.animationInterval);
                    this.animationInterval = null;
                }
                
                // 清理所有活动的timeout
                this.activeTimeouts.forEach(timeoutId => {
                    clearTimeout(timeoutId);
                });
                this.activeTimeouts.clear();
                
                // 重置状态
                this.isAnimationRunning = false;
                this.lastScrollHeight = 0; // 重置滚动高度记录
                
                // 如果正在渐进式渲染，恢复完整内容
                if (this.targetContainer && this.currentContent) {
                    this.targetContainer.srcdoc = this.currentContent;
                }
            }
            
            // 重置动画状态，允许重新播放
            resetForNewContent() {
                this.hasPlayedOnce = false;
                this.stopAnimation();
                console.log('Claude动画状态已重置，准备播放新内容...');
            }
            
            // 启动新内容的渐进式渲染
            startProgressiveRendering(newContent) {
                // 检查全局动画开关是否开启
                if (!this.isActive) {
                    console.log('Claude动画已关闭，直接显示内容...');
                    this.showContentDirectly(newContent);
                    return;
                }
                
                // 检查是否是真正的新内容
                if (this.currentContent === newContent && this.hasPlayedOnce) {
                    console.log('内容未变化且已播放过，跳过动画...');
                    return;
                }
                
                // 只有内容改变时才重置状态
                if (this.currentContent !== newContent) {
                    console.log('检测到新内容，重置动画状态...');
                    this.currentContent = newContent;
                    this.resetForNewContent();
                } else if (this.hasPlayedOnce) {
                    console.log('相同内容已播放过，跳过动画...');
                    return;
                }
                
                // 查找目标容器
                const contentContainer = document.getElementById('claudeOutputContent');
                const iframe = contentContainer.querySelector('iframe');
                if (iframe) {
                    this.targetContainer = iframe;
                    this.runProgressiveRendering();
                }
            }
            
            // 直接显示内容（不播放动画）
            showContentDirectly(content) {
                const contentContainer = document.getElementById('claudeOutputContent');
                const iframe = contentContainer.querySelector('iframe');
                if (iframe) {
                    iframe.srcdoc = content;
                    console.log('内容已直接显示，无动画效果');
                }
            }
            
            async runThinkingAnimation() {
                if (!this.isActive) return;
                
                for (let i = 0; i < this.thinkingSteps.length; i++) {
                    if (!this.isActive) break;
                    
                    // 显示思考气泡
                    this.showThinkingBubble(this.thinkingSteps[i]);
                    
                    // 等待一段时间
                    await this.delay(2000);
                }
                
                // 思考完成后隐藏气泡，不再循环
                if (this.isActive) {
                    await this.delay(1000);
                    this.hideBubble();
                    this.hasPlayedOnce = true; // 标记已播放完成
                    console.log('Claude思考动画播放完成');
                }
            }
            
            async runProgressiveRendering() {
                if (!this.isActive || !this.currentContent) return;
                
                this.isAnimationRunning = true;
                
                // 显示创作气泡
                this.showCreationBubble();
                
                // 使用预渲染方案：完整内容预渲染 + CSS控制显示
                await this.runPreRenderedAnimation();
                
                this.isAnimationRunning = false;
                
                // 完成后显示完成状态
                this.showCompletionBubble();
                
                // 标记已播放完成
                this.hasPlayedOnce = true;
                
                // 动画播放完毕，保持完成状态，不再循环
                console.log('Claude动画播放完成，等待新内容...');
            }
            
            // ===== 方案4改进版：全透明渲染 + 逐步显示 =====
            
            // 主要的预渲染动画执行器（方案A版本）
            async runPreRenderedAnimation() {
                console.log('开始预渲染动画（方案A）...');
                
                // 第一步：预处理HTML，在每个元素上添加内联透明样式
                const fullContent = this.currentContent;
                const transparentContent = this.injectTransparencyStyles(fullContent);
                
                console.log('设置预处理后的内容到iframe...');
                this.targetContainer.srcdoc = transparentContent;
                
                // 第二步：等待iframe加载完成
                await this.waitForIframeLoad();
                
                console.log('iframe加载完成，页面应该已经是透明状态');
                
                // 第三步：验证透明状态
                try {
                    const iframeDoc = this.targetContainer.contentDocument;
                    const firstElement = iframeDoc.querySelector('div, p, h1, h2, h3');
                    if (firstElement) {
                        const opacity = window.getComputedStyle(firstElement).opacity;
                        console.log('验证：第一个元素的透明度为:', opacity);
                    }
                } catch (e) {
                    console.log('验证透明状态时出错:', e);
                }
                
                // 第四步：创建显示计划
                const displayPlan = this.createElementDisplayPlan();
                
                console.log('显示计划创建完成，元素数量:', displayPlan.length);
                
                if (displayPlan.length === 0) {
                    console.log('警告：没有找到任何需要显示的元素！');
                    return;
                }
                
                // 第五步：逐步显示元素
                await this.executeElementDisplay(displayPlan);
            }
            
            // 在HTML内容中注入透明样式（方案A：预处理HTML版本）
            injectTransparencyStyles(htmlContent) {
                console.log('开始HTML预处理，直接在元素上添加内联样式...');
                
                // 第一步：添加基础CSS
                const basicCSS = `
<style id="claude-transparency-styles">
/* 基础过渡样式 */
body {
    opacity: 1 !important;
    background: white !important;
}

/* 避免影响特殊元素 */
script, style, meta, link, title, noscript, head {
    opacity: 1 !important;
}
</style>`;

                // 第二步：预处理HTML，给每个可见元素添加内联透明样式
                let processedHTML = this.addInlineTransparencyToHTML(htmlContent);
                
                // 第三步：注入基础CSS
                if (processedHTML.includes('<head>')) {
                    processedHTML = processedHTML.replace('<head>', '<head>' + basicCSS);
                } else if (processedHTML.includes('<html')) {
                    processedHTML = processedHTML.replace(/(<html[^>]*>)/i, '$1' + basicCSS);
                } else {
                    processedHTML = basicCSS + processedHTML;
                }
                
                console.log('HTML预处理完成');
                return processedHTML;
            }
            
            // 核心方法：在HTML字符串中给每个元素添加内联透明样式
            addInlineTransparencyToHTML(htmlContent) {
                console.log('正在解析HTML并添加内联样式...');
                
                // 要处理的HTML标签（排除特殊标签）
                const tagsToProcess = [
                    'div', 'p', 'span', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
                    'a', 'li', 'ul', 'ol', 'td', 'th', 'tr', 'table',
                    'img', 'svg', 'canvas', 'figure', 'figcaption',
                    'input', 'textarea', 'select', 'button',
                    'strong', 'em', 'code', 'pre', 'blockquote',
                    'section', 'article', 'header', 'footer', 'nav', 'main', 'aside'
                ];
                
                let processedHTML = htmlContent;
                let processedCount = 0;
                
                // 遍历每种标签类型
                tagsToProcess.forEach(tag => {
                    // 匹配开始标签的正则表达式
                    const tagRegex = new RegExp(`<${tag}([^>]*)>`, 'gi');
                    
                    processedHTML = processedHTML.replace(tagRegex, (match, attributes) => {
                        processedCount++;
                        
                        // 检查是否已经有style属性
                        if (attributes.includes('style=')) {
                            // 如果已有style，在现有样式后添加透明度
                            return match.replace(/style=["']([^"']*)["']/i, (styleMatch, existingStyles) => {
                                const transparencyStyle = 'opacity:0;transition:opacity 0.8s ease-in-out;';
                                return `style="${existingStyles};${transparencyStyle}"`;
                            });
                        } else {
                            // 如果没有style，添加新的style属性
                            const transparencyStyle = ` style="opacity:0;transition:opacity 0.8s ease-in-out;"`;
                            return `<${tag}${attributes}${transparencyStyle}>`;
                        }
                    });
                });
                
                console.log(`已为 ${processedCount} 个元素添加内联透明样式`);
                return processedHTML;
            }
            
            // 直接设置所有元素为透明
            async setAllElementsTransparent() {
                try {
                    const iframe = this.targetContainer;
                    if (!iframe || !iframe.contentWindow) return;
                    
                    const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                    if (!iframeDoc) return;
                    
                    // 获取所有元素
                    const allElements = iframeDoc.querySelectorAll('*');
                    let count = 0;
                    
                    allElements.forEach(element => {
                        const tagName = element.tagName.toLowerCase();
                        
                        // 跳过不需要处理的元素
                        if (['script', 'style', 'meta', 'link', 'title', 'noscript', 'head', 'html', 'body'].includes(tagName)) {
                            return;
                        }
                        
                        // 直接设置内联样式
                        element.style.opacity = '0';
                        element.style.transition = 'opacity 0.8s ease-in-out';
                        element.classList.add('claude-element-transition');
                        count++;
                    });
                    
                    console.log(`已设置 ${count} 个元素为透明状态`);
                    
                    // 等待一下确保样式应用
                    await this.delay(200);
                    
                } catch (error) {
                    console.log('设置元素透明时出错:', error);
                }
            }
            
            // 创建元素显示计划（叶子节点优先版本）
            createElementDisplayPlan() {
                try {
                    const iframe = this.targetContainer;
                    if (!iframe || !iframe.contentWindow) return [];
                    
                    const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                    if (!iframeDoc) return [];
                    
                    // 获取所有元素
                    const allElements = iframeDoc.querySelectorAll('*');
                    const plan = [];
                    
                    allElements.forEach((element, index) => {
                        const tagName = element.tagName.toLowerCase();
                        
                        // 跳过不需要显示的元素
                        if (['script', 'style', 'meta', 'link', 'title', 'noscript', 'head', 'html', 'body'].includes(tagName)) {
                            return;
                        }
                        
                        // 只选择叶子节点（没有子元素）或者包含直接文本的元素
                        const isLeafNode = element.children.length === 0;
                        const hasDirectText = this.hasDirectText(element);
                        const isVisualElement = ['IMG', 'SVG', 'CANVAS', 'INPUT', 'BUTTON', 'SELECT', 'TEXTAREA'].includes(element.tagName);
                        
                        // 优先选择叶子节点或有直接文本内容的元素
                        if (isLeafNode || hasDirectText || isVisualElement) {
                            const hasContent = element.textContent && element.textContent.trim().length > 0;
                            
                            if (hasContent || isVisualElement) {
                                plan.push({
                                    element: element,
                                    index: index,
                                    delay: this.getDelayForElement(element),
                                    type: this.getElementType(element),
                                    content: element.textContent ? element.textContent.trim().substring(0, 30) + '...' : element.tagName,
                                    isLeaf: isLeafNode
                                });
                            }
                        }
                    });
                    
                    // 按DOM顺序排序，叶子节点优先
                    plan.sort((a, b) => {
                        if (a.isLeaf !== b.isLeaf) {
                            return a.isLeaf ? -1 : 1; // 叶子节点优先
                        }
                        return a.index - b.index;
                    });
                    
                    console.log(`找到 ${plan.length} 个叶子节点需要渐进显示:`, plan.slice(0, 5).map(p => ({
                        tag: p.element.tagName,
                        content: p.content,
                        isLeaf: p.isLeaf
                    })));
                    
                    return plan;
                } catch (error) {
                    console.log('获取元素计划时出错:', error);
                    return [];
                }
            }
            
            // 执行元素显示（增加基础延迟让过程更明显）
            async executeElementDisplay(plan) {
                for (let i = 0; i < plan.length; i++) {
                    if (!this.isActive) break;
                    
                    const step = plan[i];
                    
                    // 显示当前元素
                    this.showElement(step.element);
                    
                    // 平滑滚动到元素位置
                    this.smoothScrollToElement(step.element);
                    
                    // 更新气泡进度
                    this.updateBubbleProgress(i + 1, plan.length);
                    this.updateBubblePosition();
                    
                    // 减慢显示速度，让过程更明显
                    const baseDelay = 500; // 增加基础延迟
                    const elementDelay = Math.min(step.delay, 300); // 减少变动范围
                    const randomDelay = Math.random() * 300; // 适度随机
                    const totalDelay = baseDelay + elementDelay + randomDelay;
                    
                    await this.delay(totalDelay);
                }
            }
            
            // 检测元素是否包含直接文本（不包括子元素文本）
            hasDirectText(element) {
                for (let node of element.childNodes) {
                    if (node.nodeType === 3 && node.textContent.trim().length > 0) { // TEXT_NODE = 3
                        return true;
                    }
                }
                return false;
            }
            
            // 显示特定元素（方案A版本 - 覆盖内联样式）
            showElement(element) {
                try {
                    if (element) {
                        console.log('正在显示元素:', element.tagName, element.textContent?.substring(0, 20));
                        
                        // 首先确保所有父容器都是可见的
                        let parent = element.parentElement;
                        while (parent && parent !== this.targetContainer.contentDocument.body && parent !== this.targetContainer.contentDocument.documentElement) {
                            if (parent.style.opacity === '0' || parent.style.opacity === '') {
                                console.log('正在显示父容器:', parent.tagName);
                                parent.style.opacity = '1';
                                // 父容器使用更快的过渡
                                if (!parent.style.transition.includes('opacity')) {
                                    parent.style.transition = 'opacity 0.2s ease-in-out';
                                }
                            }
                            parent = parent.parentElement;
                        }
                        
                        // 然后显示目标元素
                        element.style.opacity = '1';
                        
                        // 确保过渡效果
                        if (!element.style.transition.includes('opacity')) {
                            element.style.transition = 'opacity 0.8s ease-in-out';
                        }
                        
                        // 验证设置是否成功
                        setTimeout(() => {
                            const currentOpacity = element.style.opacity;
                            console.log(`元素 ${element.tagName} 显示后透明度:`, currentOpacity);
                        }, 100);
                    }
                } catch (error) {
                    console.log('显示元素时出错:', error);
                }
            }
            
            // 平滑滚动到元素
            smoothScrollToElement(element) {
                try {
                    const iframe = this.targetContainer;
                    if (!iframe || !iframe.contentWindow || !element) return;
                    
                    const iframeWindow = iframe.contentWindow;
                    const elementTop = element.offsetTop;
                    const viewportHeight = iframeWindow.innerHeight || 400;
                    
                    // 智能滚动：将元素滚动到视窗的1/3位置
                    const targetScroll = Math.max(0, elementTop - viewportHeight / 3);
                    
                    iframeWindow.scrollTo({
                        top: targetScroll,
                        behavior: 'smooth'
                    });
                } catch (error) {
                    // 忽略跨域错误
                }
            }
            
            // 根据元素类型获取延迟时间（为细粒度显示优化）
            getDelayForElement(element) {
                const tagName = element.tagName.toLowerCase();
                const delays = {
                    'h1': 400, 'h2': 350, 'h3': 300, 'h4': 250, 'h5': 200, 'h6': 150,
                    'p': 300,
                    'div': 200,
                    'span': 150,
                    'strong': 150,
                    'em': 150,
                    'a': 150,
                    'li': 200,
                    'ul': 300, 'ol': 300,
                    'blockquote': 400,
                    'pre': 500,
                    'code': 200,
                    'img': 300,
                    'svg': 250,
                    'canvas': 300,
                    'table': 400,
                    'tr': 200,
                    'td': 150, 'th': 150,
                    'section': 300,
                    'article': 350,
                    'input': 200,
                    'button': 200,
                    'textarea': 250,
                    'select': 200
                };
                return delays[tagName] || 200;
            }
            
            // 获取元素类型
            getElementType(element) {
                const tagName = element.tagName.toLowerCase();
                if (['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(tagName)) {
                    return 'heading';
                } else if (tagName === 'p') {
                    return 'paragraph';
                } else if (['ul', 'ol'].includes(tagName)) {
                    return 'list';
                } else if (tagName === 'img') {
                    return 'image';
                } else if (['pre', 'code'].includes(tagName)) {
                    return 'code';
                } else {
                    return 'content';
                }
            }
            parseHTMLIntoChunks(htmlContent) {
                // 智能分割HTML内容
                const chunks = [];
                
                // 首先添加DOCTYPE和html开始标签
                if (htmlContent.includes('<!DOCTYPE')) {
                    chunks.push('<!DOCTYPE html>');
                    htmlContent = htmlContent.replace('<!DOCTYPE html>', '');
                }
                
                // 分割主要HTML标签
                const majorTags = ['<html', '<head', '<style', '<body', '<header', '<nav', '<main', '<section', '<article', '<div', '<footer'];
                
                let currentPos = 0;
                let currentChunk = '';
                
                while (currentPos < htmlContent.length) {
                    let nextTagPos = htmlContent.length;
                    let foundTag = null;
                    
                    // 找到下一个主要标签的位置
                    for (const tag of majorTags) {
                        const pos = htmlContent.indexOf(tag, currentPos);
                        if (pos !== -1 && pos < nextTagPos) {
                            nextTagPos = pos;
                            foundTag = tag;
                        }
                    }
                    
                    // 如果找到了标签，分割内容
                    if (foundTag && nextTagPos > currentPos) {
                        currentChunk += htmlContent.substring(currentPos, nextTagPos);
                        if (currentChunk.trim()) {
                            chunks.push(currentChunk);
                        }
                        
                        // 找到完整的标签（包括结束标签）
                        const tagEnd = this.findCompleteTag(htmlContent, nextTagPos);
                        currentChunk = htmlContent.substring(nextTagPos, tagEnd);
                        currentPos = tagEnd;
                    } else {
                        // 没有更多标签，添加剩余内容
                        currentChunk += htmlContent.substring(currentPos);
                        break;
                    }
                }
                
                if (currentChunk.trim()) {
                    chunks.push(currentChunk);
                }
                
                // 确保至少有一些chunk
                if (chunks.length === 0) {
                    const lines = htmlContent.split('\n');
                    for (let i = 0; i < lines.length; i += 3) {
                        chunks.push(lines.slice(i, i + 3).join('\n'));
                    }
                }
                
                return chunks.filter(chunk => chunk.trim());
            }
            
            findCompleteTag(html, startPos) {
                // 简化实现：找到下一个>位置
                const closePos = html.indexOf('>', startPos);
                return closePos !== -1 ? closePos + 1 : startPos + 50;
            }
            
            showThinkingBubble(message) {
                if (!this.collaborationBubble) return;
                
                // 更新气泡内容
                const nameSpan = this.collaborationBubble.querySelector('.bubble-name');
                nameSpan.textContent = message;
                
                // 显示在Claude容器右上角
                this.positionBubbleAtContainer();
                this.updateBubbleStatus('thinking');
                this.collaborationBubble.classList.add('active', 'floating');
            }
            
            showCreationBubble() {
                if (!this.collaborationBubble) return;
                
                const nameSpan = this.collaborationBubble.querySelector('.bubble-name');
                nameSpan.textContent = '正在创建网页...';
                
                this.positionBubbleAtContainer();
                this.updateBubbleStatus('typing');
                this.collaborationBubble.classList.add('active', 'floating');
            }
            
            updateBubbleProgress(current, total) {
                if (!this.collaborationBubble) return;
                
                const nameSpan = this.collaborationBubble.querySelector('.bubble-name');
                nameSpan.textContent = `渲染进度 ${current}/${total}`;
            }
            
            showCompletionBubble() {
                if (!this.collaborationBubble) return;
                
                const nameSpan = this.collaborationBubble.querySelector('.bubble-name');
                nameSpan.textContent = '网页创建完成！';
                
                this.updateBubbleStatus('selecting');
            }
            
            positionBubbleAtContainer() {
                if (!this.collaborationBubble) return;
                
                const claudeContainer = document.querySelector('.claude-output-container');
                const containerRect = claudeContainer.getBoundingClientRect();
                
                // 定位在容器右上角内部
                const bubbleWidth = 200;
                const x = claudeContainer.clientWidth - bubbleWidth - 20;
                const y = 80; // 工具栏下方
                
                this.collaborationBubble.style.left = x + 'px';
                this.collaborationBubble.style.top = y + 'px';
                this.collaborationBubble.style.setProperty('--arrow-direction', 'down');
            }
            
            updateBubbleStatus(status) {
                const statusDot = this.collaborationBubble.querySelector('.bubble-status');
                statusDot.className = `bubble-status ${status}`;
            }
            
            hideBubble() {
                if (this.collaborationBubble) {
                    this.collaborationBubble.classList.remove('active', 'floating');
                }
            }
            
            // 等待iframe内容加载完成
            async waitForIframeLoad() {
                return new Promise(resolve => {
                    // 增加延迟，确保iframe内容完全加载并渲染
                    setTimeout(resolve, 500);
                });
            }
            
            // 自动滚动到新生成的内容（智能防抖动版本）
            scrollToNewContent() {
                try {
                    const iframe = this.targetContainer;
                    if (!iframe || !iframe.contentWindow) return;
                    
                    const iframeWindow = iframe.contentWindow;
                    const iframeDoc = iframe.contentDocument || iframeWindow.document;
                    
                    if (!iframeDoc || !iframeDoc.body) return;
                    
                    // 获取内容高度信息
                    const scrollHeight = Math.max(
                        iframeDoc.documentElement.scrollHeight,
                        iframeDoc.body.scrollHeight,
                        iframeDoc.documentElement.offsetHeight,
                        iframeDoc.body.offsetHeight
                    );
                    
                    const clientHeight = iframeWindow.innerHeight || iframe.clientHeight;
                    const currentScrollTop = iframeWindow.pageYOffset || iframeDoc.documentElement.scrollTop || iframeDoc.body.scrollTop || 0;
                    
                    // 如果内容高度不足一屏，不需要滚动
                    if (scrollHeight <= clientHeight + 50) return;
                    
                    // 记录上次的滚动高度，避免重复滚动
                    if (!this.lastScrollHeight) {
                        this.lastScrollHeight = 0;
                    }
                    
                    // 只有当内容高度明显增加时才滚动（防止频繁的小幅滚动）
                    const heightDelta = scrollHeight - this.lastScrollHeight;
                    if (heightDelta < 100) return; // 内容增加不足100px时不滚动
                    
                    // 计算是否需要滚动：检查用户是否能看到新内容
                    const viewportBottom = currentScrollTop + clientHeight;
                    const needScroll = scrollHeight > viewportBottom + 200; // 给200px缓冲区
                    
                    if (!needScroll) {
                        this.lastScrollHeight = scrollHeight;
                        return;
                    }
                    
                    // 智能滚动策略：基于当前位置平滑向下滚动
                    const contentRatio = scrollHeight / clientHeight;
                    let scrollAmount;
                    
                    if (contentRatio < 1.5) {
                        // 内容不多时，小步滚动
                        scrollAmount = Math.min(heightDelta, clientHeight * 0.3);
                    } else if (contentRatio < 3) {
                        // 中等内容，中步滚动
                        scrollAmount = Math.min(heightDelta, clientHeight * 0.5);
                    } else {
                        // 长内容，大步滚动但不超过新增内容
                        scrollAmount = Math.min(heightDelta * 1.2, clientHeight * 0.7);
                    }
                    
                    const targetScroll = Math.min(
                        currentScrollTop + scrollAmount,
                        scrollHeight - clientHeight
                    );
                    
                    // 只有目标位置与当前位置有明显差异时才滚动
                    if (Math.abs(targetScroll - currentScrollTop) > 50) {
                        iframeWindow.scrollTo({
                            top: targetScroll,
                            behavior: 'smooth'
                        });
                    }
                    
                    this.lastScrollHeight = scrollHeight;
                    
                } catch (error) {
                    // 忽略跨域或其他滚动错误，这在iframe中是常见的
                    // console.log('滚动时出现跨域限制，这是正常现象');
                }
            }
            
            // 更新气泡位置以跟随滚动进度
            updateBubblePosition() {
                // 气泡保持在Claude容器的固定位置，不跟随iframe内部滚动
                // 这样用户始终能看到Claude的创作状态
                this.positionBubbleAtContainer();
            }
            
            delay(ms) {
                return new Promise(resolve => {
                    const timeoutId = setTimeout(resolve, ms);
                    this.activeTimeouts.add(timeoutId);
                });
            }
            
            // 公共方法：外部调用以开始渐进式渲染
            startProgressiveRendering(htmlContent) {
                // 检查是否有新内容
                const hasNewContent = this.currentContent !== htmlContent;
                
                this.currentContent = htmlContent;
                const contentContainer = document.getElementById('claudeOutputContent');
                const iframe = contentContainer.querySelector('iframe');
                this.targetContainer = iframe;
                
                if (this.isActive && hasNewContent) {
                    console.log('检测到新内容，重启Claude动画...');
                    // 停止当前动画
                    this.stopAnimation();
                    // 重新开始渲染动画
                    this.runProgressiveRendering();
                }
            }
        }
        
        // 初始化协作动画系统
        let excelAnimator;
        let wordAnimator;
        let claudeAnimator;
        
        // 初始化：隐藏对话历史区域
        chatMessages.classList.add('empty');

        // 自动调整输入框高度
        chatInput.addEventListener('input', function() {
            this.style.height = 'auto';
            this.style.height = Math.min(this.scrollHeight, 100) + 'px';
        });

        // 回车发送消息
        chatInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });

        // 发送按钮点击事件
        sendButton.addEventListener('click', sendMessage);

        async function sendMessage() {
            const message = chatInput.value.trim();
            if (!message) return;

            // 禁用发送按钮
            sendButton.disabled = true;
            sendButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';

            // 添加用户消息到聊天界面
            addMessage(message, 'user');
            
            // 添加到对话历史
            conversationHistory.push({
                role: 'user',
                content: message
            });
            
            // 清空输入框
            chatInput.value = '';
            chatInput.style.height = 'auto';

            // 创建AI消息容器（用于流式更新）
            const aiMessageDiv = createAIMessageContainer();
            let fullResponse = '';

            try {
                let finalMessage = message;
                
                // 获取选中的文档内容
                const selectedDocs = getSelectedDocumentsContent();
                
                // 如果有选中的文档，将它们作为附件添加到消息中
                if (selectedDocs.length > 0) {
                    finalMessage += "\n\n--- 附件文档 ---\n";
                    selectedDocs.forEach((doc, index) => {
                        finalMessage += `\n附件 ${index + 1}: ${doc.title} (${doc.type})\n`;
                        finalMessage += "内容:\n" + doc.content + "\n";
                        finalMessage += "-".repeat(50) + "\n";
                    });
                    finalMessage += "\n请基于以上附件内容来回答我的问题。";
                }
                
                // 如果用户请求创建文档，添加HTML格式要求
                if (isDocumentCreationRequest(message)) {
                    finalMessage += "\n\nPlease create this as a complete HTML document with proper styling using CSS. Include all necessary HTML structure (<!DOCTYPE html>, <html>, <head>, <body>, etc.)";
                }
                
                // 调用后端API (流式)
                const response = await fetch(`${API_BASE_URL}/chat`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        message: finalMessage,
                        history: conversationHistory.slice(0, -1) // 不包含当前消息
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                // 处理流式响应
                const reader = response.body.getReader();
                const decoder = new TextDecoder();

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    const chunk = decoder.decode(value);
                    const lines = chunk.split('\n');

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const jsonStr = line.slice(6);
                            if (jsonStr.trim() === '') continue;

                            try {
                                const data = JSON.parse(jsonStr);
                                
                                if (data.error) {
                                    throw new Error(data.error);
                                }
                                
                                if (data.content) {
                                    fullResponse += data.content;
                                    updateAIMessage(aiMessageDiv, fullResponse);
                                }
                                
                                if (data.done) {
                                    // 流式响应完成
                                    break;
                                }
                            } catch (parseError) {
                                if (jsonStr.trim() !== '') {
                                    console.warn('Failed to parse JSON:', jsonStr);
                                }
                            }
                        }
                    }
                }

                // 添加完整回复到对话历史（使用原始消息，不是修改后的）
                conversationHistory.push({
                    role: 'assistant',
                    content: fullResponse
                });

                // 如果回复包含代码或HTML，或者是文档创建请求，显示在Claude输出容器中
                if (isWebContent(fullResponse) || isDocumentCreationRequest(message)) {
                    showClaudeOutput(fullResponse, isDocumentCreationRequest(message));
                }
                
            } catch (error) {
                console.error('Error calling Claude API:', error);
                
                // 显示错误消息
                let errorMessage = '抱歉，连接AI服务时出现问题。';
                if (error.message.includes('Failed to fetch')) {
                    errorMessage = '无法连接到AI服务。请确保后端服务正在运行 (python server.py)。';
                } else if (error.message.includes('HTTP error')) {
                    errorMessage = 'AI服务响应错误，请稍后重试。';
                } else {
                    errorMessage = `错误: ${error.message}`;
                }
                
                // 如果已经创建了AI消息容器，更新它显示错误
                if (aiMessageDiv) {
                    updateAIMessage(aiMessageDiv, errorMessage);
                } else {
                    addMessage(errorMessage, 'ai');
                }
            } finally {
                // 重新启用发送按钮
                sendButton.disabled = false;
                sendButton.innerHTML = '<i class="fas fa-paper-plane"></i>';
            }
        }

        function createAIMessageContainer() {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message ai';
            
            const avatar = document.createElement('div');
            avatar.className = 'message-avatar';
            avatar.textContent = 'AI';
            
            const messageContent = document.createElement('div');
            messageContent.className = 'message-content';
            messageContent.textContent = '';
            
            messageDiv.appendChild(avatar);
            messageDiv.appendChild(messageContent);
            
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            
            return messageContent;
        }

        function updateAIMessage(messageElement, content) {
            messageElement.textContent = content;
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function addMessage(content, type) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}`;
            
            const avatar = document.createElement('div');
            avatar.className = 'message-avatar';
            avatar.textContent = type === 'user' ? 'U' : 'AI';
            
            const messageContent = document.createElement('div');
            messageContent.className = 'message-content';
            messageContent.textContent = content;
            
            messageDiv.appendChild(avatar);
            messageDiv.appendChild(messageContent);
            
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;

            // 显示对话历史区域（移除empty类）
            chatMessages.classList.remove('empty');

            // 只有当AI回复包含HTML/网页内容时才显示Claude容器
            if (type === 'ai' && isWebContent(content)) {
                showClaudeOutput(content);
            } else if (type === 'ai') {
                // 如果AI回复不是网页内容，隐藏Claude容器
                hideClaudeOutput();
            }
        }

        // 获取选中文档的内容
        function getSelectedDocumentsContent() {
            const selectedDocs = [];
            
            // 检查Excel容器是否被选中
            const excelContainer = document.querySelector('.excel-container');
            if (excelContainer && excelContainer.classList.contains('selected')) {
                const excelContent = extractExcelContent();
                if (excelContent) {
                    selectedDocs.push({
                        type: 'excel',
                        title: 'PPT Template Search Data',
                        content: excelContent
                    });
                }
            }
            
            // 检查Word容器是否被选中
            const wordContainer = document.querySelector('.word-container');
            if (wordContainer && wordContainer.classList.contains('selected')) {
                const wordContent = extractWordContent();
                if (wordContent) {
                    selectedDocs.push({
                        type: 'word',
                        title: 'PPT Template User Research Report',
                        content: wordContent
                    });
                }
            }
            
            // 检查Claude容器是否被选中
            const claudeContainer = document.getElementById('claudeOutputContainer');
            if (claudeContainer && claudeContainer.classList.contains('selected')) {
                const claudeContent = extractClaudeContent();
                if (claudeContent) {
                    selectedDocs.push({
                        type: 'claude_output',
                        title: 'Claude Task Output',
                        content: claudeContent
                    });
                }
            }
            
            return selectedDocs;
        }

        // 提取Excel内容
        function extractExcelContent() {
            const table = document.querySelector('.excel-table');
            if (!table) return null;
            
            let content = "PPT Template Search Data:\n\n";
            const rows = table.querySelectorAll('tr');
            
            rows.forEach((row, index) => {
                const cells = row.querySelectorAll('th, td');
                const rowData = Array.from(cells).map(cell => cell.textContent.trim());
                
                if (index === 0) {
                    content += rowData.join(' | ') + '\n';
                    content += '-'.repeat(50) + '\n';
                } else {
                    content += rowData.join(' | ') + '\n';
                }
            });
            
            return content;
        }

        // 提取Word内容
        function extractWordContent() {
            const wordDocument = document.querySelector('.word-document');
            if (!wordDocument) return null;
            
            let content = "PPT Template User Research Report\n";
            content += "Market Analysis & User Behavior Study | December 2024\n\n";
            
            const sections = wordDocument.querySelectorAll('.word-section');
            sections.forEach(section => {
                const heading = section.querySelector('h3');
                if (heading) {
                    content += heading.textContent + '\n';
                    content += '='.repeat(heading.textContent.length) + '\n';
                }
                
                const paragraphs = section.querySelectorAll('p');
                paragraphs.forEach(p => {
                    content += p.textContent + '\n\n';
                });
                
                const lists = section.querySelectorAll('ul, ol');
                lists.forEach(list => {
                    const items = list.querySelectorAll('li');
                    items.forEach(item => {
                        content += '• ' + item.textContent + '\n';
                    });
                    content += '\n';
                });
            });
            
            return content;
        }

        // 提取Claude输出内容
        function extractClaudeContent() {
            const claudeContent = document.getElementById('claudeOutputContent');
            if (!claudeContent) return null;
            
            const iframe = claudeContent.querySelector('iframe');
            if (iframe) {
                try {
                    // 尝试获取iframe内容
                    return iframe.srcdoc || 'Claude generated HTML content (iframe)';
                } catch (e) {
                    return 'Claude generated content (unable to extract due to security restrictions)';
                }
            }
            
            return claudeContent.textContent.trim() || null;
        }

        // 检查用户是否要求创建文档
        function isDocumentCreationRequest(message) {
            const messageLower = message.toLowerCase();
            
            // 例外情况：如果是学习模板的请求，不触发文档创建模式
            if (messageLower.includes('learn this as template') || 
                messageLower.includes('learn this template') ||
                messageLower.includes('study this template')) {
                return false;
            }
            
            const documentKeywords = [
                'slide', 'slides', 'presentation', 'ppt', 'powerpoint',
                'word', 'document', 'doc', 'docx', 
                'excel', 'spreadsheet', 'table', 'xlsx',
                'create', 'make', 'generate', 'build', 'design'
            ];
            
            // 检查是否包含创建文档的关键词组合
            const hasDocumentKeyword = documentKeywords.some(keyword => 
                messageLower.includes(keyword));
            
            const hasCreationKeyword = ['create', 'make', 'generate', 'build', 'design'].some(keyword =>
                messageLower.includes(keyword));
            
            return hasDocumentKeyword && (hasCreationKeyword || 
                messageLower.includes('create') || 
                messageLower.includes('make') ||
                messageLower.includes('generate') ||
                messageLower.includes('build') ||
                messageLower.includes('design'));
        }

        function isWebContent(content) {
            // 检查是否包含HTML代码块或HTML标签
            const hasHtmlCodeBlock = content.includes('```html') || content.includes('```HTML');
            const hasHtmlTags = content.includes('<') && content.includes('>');
            
            // 检查是否包含常见的HTML元素
            const htmlElements = ['<html', '<div', '<p>', '<span', '<h1', '<h2', '<h3', 
                                 '<button', '<input', '<form', '<style', '<script', 
                                 '<header', '<footer', '<nav', '<section', '<article'];
            
            const hasHtmlElements = htmlElements.some(tag => 
                content.toLowerCase().includes(tag.toLowerCase()));
            
            return (hasHtmlCodeBlock || hasHtmlTags) && hasHtmlElements;
        }

        function extractHtmlContent(content) {
            // 方法1: 提取 ```html 代码块
            const htmlCodeBlockRegex = /```html\s*([\s\S]*?)\s*```/i;
            const htmlCodeMatch = content.match(htmlCodeBlockRegex);
            if (htmlCodeMatch) {
                return htmlCodeMatch[1].trim();
            }
            
            // 方法2: 提取 ``` 代码块（可能不标注html）
            const codeBlockRegex = /```\s*([\s\S]*?)\s*```/;
            const codeMatch = content.match(codeBlockRegex);
            if (codeMatch) {
                const codeContent = codeMatch[1].trim();
                // 检查是否是HTML内容
                if (codeContent.includes('<') && codeContent.includes('>')) {
                    return codeContent;
                }
            }
            
            // 方法3: 提取从<!DOCTYPE或<html开始的完整HTML
            const htmlDocRegex = /(<!DOCTYPE[\s\S]*)/i;
            const htmlDocMatch = content.match(htmlDocRegex);
            if (htmlDocMatch) {
                return htmlDocMatch[1].trim();
            }
            
            // 方法4: 提取最大的HTML标签块
            const htmlTagRegex = /(<[^>]+>[\s\S]*?<\/[^>]+>)/;
            const htmlTagMatch = content.match(htmlTagRegex);
            if (htmlTagMatch) {
                // 找到第一个标签后，尝试提取整个HTML结构
                const startIndex = content.indexOf(htmlTagMatch[1]);
                const possibleHtml = content.substring(startIndex);
                
                // 简单的HTML结构提取
                let htmlContent = '';
                let tagStack = [];
                let i = 0;
                
                while (i < possibleHtml.length) {
                    if (possibleHtml[i] === '<') {
                        const tagEnd = possibleHtml.indexOf('>', i);
                        if (tagEnd !== -1) {
                            const tag = possibleHtml.substring(i, tagEnd + 1);
                            htmlContent += tag;
                            
                            // 简单的标签匹配检查
                            if (tag.includes('</')) {
                                tagStack.pop();
                            } else if (!tag.includes('/>') && !tag.includes('<br') && !tag.includes('<hr')) {
                                tagStack.push(tag);
                            }
                            
                            i = tagEnd + 1;
                            
                            // 如果标签栈为空且我们已经有内容，说明HTML结构完整
                            if (tagStack.length === 0 && htmlContent.length > 50) {
                                break;
                            }
                        } else {
                            htmlContent += possibleHtml[i];
                            i++;
                        }
                    } else {
                        htmlContent += possibleHtml[i];
                        i++;
                    }
                }
                
                if (htmlContent.trim()) {
                    return htmlContent.trim();
                }
            }
            
            // 如果都没找到，返回原内容
            return content;
        }

        function showClaudeOutput(content, isDocumentRequest = false) {
            const claudeContainer = document.getElementById('claudeOutputContainer');
            const claudeContent = document.getElementById('claudeOutputContent');
            const claudeTitle = document.getElementById('claudeTaskTitle');
            
            // 提取HTML内容
            let htmlContent = extractHtmlContent(content);
            
            // 如果是文档创建请求但没有提取到HTML，尝试直接使用内容
            if (isDocumentRequest && !htmlContent.includes('<html')) {
                // 如果内容包含HTML标签但不是完整的HTML文档，包装它
                if (content.includes('<') && content.includes('>')) {
                    htmlContent = `<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generated Document</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; line-height: 1.6; }
    </style>
</head>
<body>
    ${content}
</body>
</html>`;
                }
            }
            
            // 更新标题
            if (isDocumentRequest) {
                claudeTitle.textContent = 'Generated Document';
            } else {
                claudeTitle.textContent = 'Generated Web Content';
            }
            
            // 显示容器
            claudeContainer.style.display = 'block';
            
            // 创建iframe来显示HTML内容
            const iframe = document.createElement('iframe');
            iframe.style.width = '100%';
            iframe.style.height = '100%';
            iframe.style.border = 'none';
            iframe.style.background = 'white';
            
            // 清空之前的内容并添加iframe
            claudeContent.innerHTML = '';
            claudeContent.appendChild(iframe);
            
            // 设置iframe的srcdoc属性以便动画系统访问
            iframe.srcdoc = htmlContent;
            
            // 如果Claude动画系统激活，启动渐进式渲染
            if (claudeAnimator && claudeAnimator.isActive) {
                claudeAnimator.startProgressiveRendering(htmlContent);
            } else {
                // 正常显示完整内容
                const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                iframeDoc.open();
                iframeDoc.write(htmlContent);
                iframeDoc.close();
            }
        }

        function hideClaudeOutput() {
            const claudeContainer = document.getElementById('claudeOutputContainer');
            claudeContainer.style.display = 'none';
        }

        // 检查后端服务状态
        async function checkServerStatus() {
            try {
                const response = await fetch(`${API_BASE_URL}/health`);
                if (response.ok) {
                    console.log('✅ 后端服务连接正常');
                    // 更新聊天输入框占位符
                    chatInput.placeholder = 'Ask Clippy Anything';
                    return true;
                }
            } catch (error) {
                console.log('❌ 后端服务未连接');
                // 更新聊天输入框占位符
                chatInput.placeholder = '请先启动后端服务 (python server.py)';
                return false;
            }
            return false;
        }

        // 页面加载时初始化
        window.addEventListener('load', function() {
            // 检查服务状态
            checkServerStatus();
        });

        // 拖拽功能
        let isDragging = false;
        let currentElement = null;
        let offset = { x: 0, y: 0 };
        let selectedDocuments = new Set();
        let mouseDownPos = { x: 0, y: 0 };
        let mouseDownTarget = null;
        const DRAG_THRESHOLD = 5;

        // 调整大小相关变量
        let isResizing = false;
        let currentResizeTarget = null;
        let resizeDirection = null;
        let originalRect = {};
        let startPos = {};

        // 为文档容器添加拖拽功能
        document.addEventListener('DOMContentLoaded', function() {
            const excelContainer = document.querySelector('.excel-container');
            const wordContainer = document.querySelector('.word-container');
            const claudeContainer = document.getElementById('claudeOutputContainer');

            // 为文档容器添加拖拽事件
            [excelContainer, wordContainer, claudeContainer].forEach(element => {
                element.addEventListener('mousedown', handleMouseDown);
                
                // 为调整大小手柄添加事件
                const resizeHandles = element.querySelectorAll('.resize-handle');
                resizeHandles.forEach(handle => {
                    handle.addEventListener('mousedown', handleResizeStart);
                });
            });

            // 为复选框添加选择事件
            const excelCheckbox = document.getElementById('excel-checkbox');
            const wordCheckbox = document.getElementById('word-checkbox');
            const claudeCheckbox = document.getElementById('claude-checkbox');

            excelCheckbox.addEventListener('change', function(e) {
                handleCheckboxChange(excelContainer, e.target.checked);
                e.stopPropagation();
            });

            wordCheckbox.addEventListener('change', function(e) {
                handleCheckboxChange(wordContainer, e.target.checked);
                e.stopPropagation();
            });

            claudeCheckbox.addEventListener('change', function(e) {
                handleCheckboxChange(claudeContainer, e.target.checked);
                e.stopPropagation();
            });

            // 防止复选框区域触发拖拽
            document.querySelectorAll('.document-checkbox').forEach(checkbox => {
                checkbox.addEventListener('mousedown', function(e) {
                    e.stopPropagation();
                });
            });

            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
            document.addEventListener('keydown', handleKeyDown);
            
            // 修复初始滚动问题：移除max-height限制，设置明确的高度
            function fixInitialScrolling() {
                [excelContainer, wordContainer].forEach(container => {
                    if (container) {
                        // 获取当前的计算高度
                        const rect = container.getBoundingClientRect();
                        const computedStyle = window.getComputedStyle(container);
                        const maxHeight = computedStyle.maxHeight;
                        
                        // 如果有max-height限制，将其转换为明确的height值
                        if (maxHeight !== 'none') {
                            container.style.maxHeight = 'none';
                            container.style.height = rect.height + 'px';
                        }
                    }
                });
            }
            
            // 在下一帧执行修复，确保CSS已经应用
            requestAnimationFrame(fixInitialScrolling);
            
            // 初始化协作动画系统
            excelAnimator = new ExcelCollaborationAnimator();
            wordAnimator = new WordCollaborationAnimator();
            claudeAnimator = new ClaudeAIAnimator();
        });

        function handleCheckboxChange(container, isChecked) {
            if (isChecked) {
                selectDocument(container);
            } else {
                deselectDocument(container);
            }
        }

        function handleMouseDown(e) {
            // 如果点击的是复选框区域，不启动拖拽
            if (e.target.closest('.document-checkbox')) {
                return;
            }

            // 如果点击的是滚动条区域，不启动拖拽
            if (e.target.scrollHeight > e.target.clientHeight && 
                e.offsetX > e.target.clientWidth - 20) {
                return;
            }

            const element = e.currentTarget;
            mouseDownTarget = element;
            mouseDownPos.x = e.clientX;
            mouseDownPos.y = e.clientY;
            
            const rect = element.getBoundingClientRect();
            offset.x = e.clientX - rect.left;
            offset.y = e.clientY - rect.top;

            e.preventDefault();
        }

        function handleMouseMove(e) {
            if (isResizing && currentResizeTarget) {
                performResize(e);
                return;
            }
            
            if (mouseDownTarget && !isDragging && !isResizing) {
                const deltaX = e.clientX - mouseDownPos.x;
                const deltaY = e.clientY - mouseDownPos.y;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                
                if (distance > DRAG_THRESHOLD) {
                    startDrag(mouseDownTarget);
                }
            }
            
            if (isDragging && currentElement) {
                drag(e);
            }
        }

        function handleMouseUp(e) {
            if (isResizing) {
                stopResize();
            } else if (isDragging) {
                stopDrag();
            }
            mouseDownTarget = null;
            mouseDownPos.x = 0;
            mouseDownPos.y = 0;
        }

        function selectDocument(element) {
            element.classList.add('selected');
            selectedDocuments.add(element);
            
            // 同步复选框状态
            const checkbox = element.querySelector('.checkbox-input');
            if (checkbox) {
                checkbox.checked = true;
            }
            
            updateSelectionInfo();
        }

        function deselectDocument(element) {
            element.classList.remove('selected');
            selectedDocuments.delete(element);
            
            // 同步复选框状态
            const checkbox = element.querySelector('.checkbox-input');
            if (checkbox) {
                checkbox.checked = false;
            }
            
            updateSelectionInfo();
        }

        function toggleSelection(element) {
            if (selectedDocuments.has(element)) {
                deselectDocument(element);
            } else {
                selectDocument(element);
            }
        }

        function clearAllSelections() {
            selectedDocuments.forEach(element => {
                element.classList.remove('selected');
                // 同步复选框状态
                const checkbox = element.querySelector('.checkbox-input');
                if (checkbox) {
                    checkbox.checked = false;
                }
            });
            selectedDocuments.clear();
            updateSelectionInfo();
        }

        function updateSelectionInfo() {
            console.log(`Selected documents: ${selectedDocuments.size}`);
            // 这里可以添加更多的选择状态反馈
        }

        function handleKeyDown(e) {
            // 按Escape键取消所有选择
            if (e.key === 'Escape') {
                clearAllSelections();
            }
            // 按Ctrl+A选择所有文档
            if ((e.ctrlKey || e.metaKey) && e.key === 'a') {
                e.preventDefault();
                const excelContainer = document.querySelector('.excel-container');
                const wordContainer = document.querySelector('.word-container');
                const claudeContainer = document.getElementById('claudeOutputContainer');
                
                selectDocument(excelContainer);
                selectDocument(wordContainer);
                
                // 只有当Claude容器可见时才选择它
                if (claudeContainer && claudeContainer.style.display !== 'none') {
                    selectDocument(claudeContainer);
                }
            }
        }

        function startDrag(element) {
            isDragging = true;
            currentElement = element;
            element.classList.add('dragging');
        }

        function drag(e) {
            if (!isDragging || !currentElement) return;
            
            e.preventDefault();
            
            const x = e.clientX - offset.x;
            const y = e.clientY - offset.y;
            
            // 限制在画布范围内
            const maxX = window.innerWidth - currentElement.offsetWidth;
            const maxY = window.innerHeight - currentElement.offsetHeight;
            
            const boundedX = Math.max(0, Math.min(x, maxX));
            const boundedY = Math.max(0, Math.min(y, maxY));
            
            currentElement.style.left = boundedX + 'px';
            currentElement.style.top = boundedY + 'px';
        }

        function stopDrag() {
            if (currentElement) {
                currentElement.classList.remove('dragging');
                currentElement = null;
            }
            isDragging = false;
        }

        // 调整大小相关函数
        function handleResizeStart(e) {
            e.preventDefault();
            e.stopPropagation();
            
            isResizing = true;
            currentResizeTarget = e.target.closest('.excel-container, .word-container, .claude-output-container');
            
            // 确定调整方向
            if (e.target.classList.contains('resize-handle-se')) {
                resizeDirection = 'se';
            } else if (e.target.classList.contains('resize-handle-e')) {
                resizeDirection = 'e';
            } else if (e.target.classList.contains('resize-handle-s')) {
                resizeDirection = 's';
            }
            
            // 记录初始位置和尺寸
            const rect = currentResizeTarget.getBoundingClientRect();
            originalRect = {
                width: rect.width,
                height: rect.height,
                left: rect.left,
                top: rect.top
            };
            
            startPos = {
                x: e.clientX,
                y: e.clientY
            };
            
            // 添加调整大小状态的样式
            currentResizeTarget.style.userSelect = 'none';
            currentResizeTarget.classList.add('resizing'); // 添加调整大小状态类
            document.body.style.cursor = e.target.style.cursor;
            
            // 临时移除CSS的高度限制，允许自由调整大小
            currentResizeTarget.style.maxHeight = 'none';
            currentResizeTarget.style.height = rect.height + 'px';
        }

        function performResize(e) {
            if (!isResizing || !currentResizeTarget) return;
            
            const deltaX = e.clientX - startPos.x;
            const deltaY = e.clientY - startPos.y;
            
            let newWidth = originalRect.width;
            let newHeight = originalRect.height;
            
            if (resizeDirection === 'se' || resizeDirection === 'e') {
                newWidth = Math.max(200, originalRect.width + deltaX);
            }
            
            if (resizeDirection === 'se' || resizeDirection === 's') {
                newHeight = Math.max(150, originalRect.height + deltaY);
            }
            
            // 确保不超出视窗边界
            const maxWidth = window.innerWidth - originalRect.left - 20;
            const maxHeight = window.innerHeight - originalRect.top - 20;
            
            newWidth = Math.min(newWidth, maxWidth);
            newHeight = Math.min(newHeight, maxHeight);
            
            currentResizeTarget.style.width = newWidth + 'px';
            currentResizeTarget.style.height = newHeight + 'px';
        }

        function stopResize() {
            if (currentResizeTarget) {
                currentResizeTarget.style.userSelect = '';
                currentResizeTarget.classList.remove('resizing'); // 移除调整大小状态类
                // 不恢复max-height限制，保持用户调整后的大小
                // 这样用户就可以自由调整容器大小而不受CSS限制
                currentResizeTarget = null;
            }
            
            document.body.style.cursor = '';
            isResizing = false;
            resizeDirection = null;
        }
    </script>
    
    <!-- 全局动画控制开关 -->
    <div class="global-animation-control">
        <i class="fas fa-play icon"></i>
        <div class="global-animation-toggle active" id="globalAnimationToggle">
            <div class="slider"></div>
        </div>
    </div>
</body>
</html>
